---
title: "kaggle-survey"
author: "minghao"
date: "October 21, 2017"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    df_print: tibble
---

# Libraries
```{r, warning = FALSE, message=FALSE}
library(purrr)
require(tidyverse)
require(data.table)
require(lubridate)
require(stringr)
require(ggvis)
require(ggplot2)
require(forcats)
require(ggmap)
require(highcharter)
require(broom)
require(plotly)


#NLP
require(quanteda)
require(wordcloud)
require(slam)

#map
require(leaflet)

#network plot
require(igraph)
```

Note that I made extensive use of data.table to extract, filter, process the data as that's the method that I'm most conformable with.

# Data Input

The following are data provided by Kaggle

```{r}

conversionRates <- as.data.table(read.csv(file="conversionRates.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = FALSE))

freeformResponses <- as.data.table(read.csv(file="freeformResponses.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = FALSE))

multipleChoiceResponses <- as.data.table(read.csv(file="multipleChoiceResponses.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = TRUE))

schema <- as.data.table(read.csv(file="schema.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = FALSE))

```

custom data that I used

```{r}
## Rcurl into data method
# library(RCurl)
# x <- getURL("https://gist.githubusercontent.com/marcusbaguley/304261/raw/0ab501897ce32fcd3aecd748b74686a20ada9036/Country%2520Currency%2520Code%2520Mappings")
# y <- read.csv(text = x)

## Reading downloaded csv method
currency2CountryName <- data.table(read.csv("Country Currency Code Mappings.csv"))
```


# Function

```{r}
# To extract the patterns of response that would follow a similar pattern on counts per value
MultipleChoice_func = function(question, dt = multipleChoiceResponses){
  
  setDT(dt) %>%
    # since the dt contained column with similar name, selecting only these column
    .[, colnames(.) %like% question, with=FALSE] %>%
    # melting wide data into long data
    melt(.,measure.vars=patterns(question), na.rm = TRUE, variable.name=question) %>%
    # Shortening the str with str_extract
    .[, eval(question):=str_extract(get(question), paste0("(?<=",eval(question),")([A-Za-z])*"))] %>%
    # Aggregate the counts
    .[,list(N=.N),
            by=c(eval(question), "value")] %>%
    .[, percentage := signif(N/sum(N),2)*100] %>%
  # The output should be plotted and processed, the numbers are already aggregated
    .[order(-N)]
}

# For some survey question that allow multiple choices ( select all that apply), the results are stored in a str list that seperated by ",", this function serve to extract it
MultipleChoiceOptions_func = function(question, dt = multipleChoiceResponses){
  
  # Turning this column into characters
  dt[, (question):= lapply(.SD, as.character ), .SDcols = question ]
  
  # I couldn't get there expresssion to change to with as.character nicely
  # `$`(df , question)<-as.character(`$`(df , question))
  # dt[,get(question)] <- as.character(dt[,get(question)])
  
  # Detecting the appropriate number of split
  t.splits <- max(lengths(strsplit(dt[,get(question)], '\\([^)]+,(*SKIP)(*FAIL)|,\\s*', 
                                   perl = TRUE)))
  
  # t.splits
  t.test <- dt[,.(get(question))] %>%
    .[, paste0("m.", eval(question),
               1:t.splits):=tstrsplit(V1,
                                      '\\([^)]+,(*SKIP)(*FAIL)|,\\s*',
                                      perl = TRUE)] %>%
    .[, colnames(.) %like% "m.*", with=FALSE] %>%
    melt(.,  measure.vars = patterns("^m.*"), na.rm = T) %>% #note that na is removed
  # This output two column by default, with value column correspodings to the individual strings. Should be processed use with aggregation.
        # Aggregate the counts
    .[,.N, by=c("value")] %>%
  # The output should be plotted and processed, the numbers are already aggregated
    .[order(-N)]
}

Wordclourd_func = function(input, dt = freeformResponses){
  
  # Creating a document-feature matrix
  dfm.txt <- dfm(eval(dt)[!is.na(get(input)), get(input)],
                remove=stopwords("english"),
                remove_symbols = T,
                remove_punct = T,
                remove_numbers = T,
                remove_url = T,
                ngrams=1:2)
  
  ## Rowsum to find individual term's frequency across all documents
  term_frequency<-row_sums(t(dfm.txt)) # This utilised row_sum
  
  ## Create word_freqs
  word_freqs <- data.frame(term = names(term_frequency), num = term_frequency)
  word_freqs
  
  # for starters, word_freqs(basically a df with terms and its frequency) can be processed with wordcloud and barplot
}

```

# Basic visualisation

This section depicts the some basic plots of survey, which could be used to explore the cross section data analysis with it's tabbed structure. 

Initially,  I intended to look at into Pay vs Experience and Demographics of countries, but it has since grown up a bit.

## Countries  {.tabset}

```{r}
# Merging the records of country for China
# in the raw data, China seems to be recorded as "People 's Republic of China", "Republic of China"
multipleChoiceResponses<-multipleChoiceResponses[grep("China",Country), Country:= "China"]

# Dropping it from factors too
multipleChoiceResponses<-droplevels(multipleChoiceResponses)

# plotting
hchart(fct_infreq(multipleChoiceResponses$Country), "column") %>%
  hc_title(text = "Respondent's Country ",
             style = list(color = "Black", useHTML = TRUE)) %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="Country", Asked]),"]",
                           eval(schema[Column=="Country", Question]),
                           "<br>Countries with < 50 counts are aggregated into Other"),
             style = list(color = "Black", useHTML = TRUE)) %>%
  hc_xAxis(text = "Countries", labels = list(rotation = 90))
  
```
Merged the records of country for China (People 's Republic of China", "Republic of China). Also,  there are seperate entries for selection of Taiwan and Hong Kong. So while it may vary depending on your definition, the sum of the three entries would make it the third countries with most survey respondents, just after India.

Overall, the majority of the surveyed users are living in US and India. Interestingly, many users also selected "Others" categories ( Or perhaps their country is less represented in the data). Given that this is the survey result on Kaggle, this is probably little surprise. There might exist other data science platforms that are more popular in Other countries, especially if that country favor another language(China, Japan, Germany).

## Tenure  {.tabset}

Tenure can probably be related to Working Experience, although, given that the question of tenure is directed to all,, this is a hazy indicator given that some might include their years of coding in their education (which typically isn't included in the years of working experience). There is no better alternative in exploring working experience though.

```{r}
hchart(fct_infreq(multipleChoiceResponses$Tenure), "column")%>%
  hc_title(text = "Tenure") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="Tenure", Asked]),"]",
                           eval(schema[Column=="Tenure", Question])
                           ))

# Create a numeric column indicative of current tenure selections
# essentially a host of if, then case to set a numeric value fr m.Tenure
multipleChoiceResponses %>%
  .[Tenure=="3 to 5 years", m.Experience :=4] %>%
  .[Tenure=="6 to 10 years", m.Experience :=8] %>%
  .[Tenure=="1 to 2 years", m.Experience :=2] %>%
  .[Tenure=="More than 10 years", m.Experience :=10]%>% 
  #~hand wavingly, though data science being a relatively young field and that the majority of survey user are in their late 20s or early 30, this figures should be alright
  .[Tenure=="Less than a year", m.Experience :=0] %>%
  .[Tenure=="I don't write code to analyze data", m.Experience :=NA]
# perhaps these people rely on tableau and the likes, in any case, this field would not be indicate of their experience in their profession, removing it

## check
# unique(multipleChoiceResponses[,.(m.Experience, Tenure)])
```


## Code Writer {.tabset}

```{r}
hchart(fct_infreq(multipleChoiceResponses$CodeWriter), "column")%>%
  hc_title(text = "CodeWriter") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="CodeWriter", Asked]),"]",
                           eval(schema[Column=="CodeWriter", Question])
                           ))
```

Interestingly, about one third of people dont work with codes. I can only think of three posible reasons, one is that they are moved up into project management roles that dont require them to work with codes. Second, they working in more of a analyst role dealing with the likes of tableau/excel or other data analyst software that dont require codes. Alternatively, it is possible that they are working in another field, and are looking to break into data science.


## Job Title  {.tabset}

```{r}
hchart(fct_infreq(multipleChoiceResponses$CurrentJobTitleSelect), "column")%>%
  hc_title(text = "Job Title") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="CurrentJobTitleSelect", Asked]),"]",
                           eval(schema[Column=="CurrentJobTitleSelect", Question])
                           ))


## Creating a list of Popular job title - Aggregate Job Title
## to be use in later section
AggrJobTitle <- multipleChoiceResponses %>%
  .[!is.na(CurrentJobTitleSelect)&!CurrentJobTitleSelect=="Other",
                        .N, 
    by = CurrentJobTitleSelect] %>%
  .[order(-N)]
```

Evidently, Data Scientist, Software Developer, Data analyst and Scientist/Researh are most popular. I  am puzzle by what is the difference between Scientist/Research and Research (Maybe Education might shed a light?), perhaps they should be aggregated into a single option? Though in that case they will be the 3rd most popular job title, even before Data analyst



## Past Job title  {.tabset}

###Select

```{r}
t.WTF <- MultipleChoiceOptions_func("PastJobTitlesSelect")
  
hchart(t.WTF, type="column", hcaes(x = value, y = N, group = value),
                                   options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
         hc_title(text = "PastJobTitlesSelect") %>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="PastJobTitlesSelect", Asked]),"]",
                                  eval(schema[Column=="PastJobTitlesSelect", Question])
         ))

```
 
### FreeForm

```{r}
## freeformResponse
# colnames(freeformResponses)
nrow(freeformResponses[!is.na(PastJobTitlesFreeForm)])
# 2094

t.WTF<-setDT(Wordclourd_func("PastJobTitlesFreeForm")) %>%
  .[order(-num)] %>%
  .[num>20,] %>%
  .[, percent:=num/sum(num)*100, ]
  

hchart(t.WTF, type="column", hcaes(x = term, y = num))


highchart() %>%   
  hc_add_series(t.WTF, "column", hcaes(x = term, y = num), name = "column") %>%
  hc_add_series(t.WTF, "pie", hcaes(name = term, y = percent), name = "Bars")
```

## Job Factor  {.tabset}

```{r}
# Extracting all column that cosist of JobFactor string.
JobFactor.Select <- MultipleChoice_func("JobFactor")

JobFactor.MSelect <- JobFactor.Select %>%
  .[, .(percent=sum(percentage)), by = JobFactor]

# hchart(t.WTF, type="column", hcaes(x = JobFactor, y = N, group = value),
                                   # options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
         # hc_title(text = "JobFactor") 

highchart() %>%   
  hc_add_series(JobFactor.Select, "column", hcaes(x = JobFactor, y = N, group = value), name = "column") %>%
  hc_add_series(JobFactor.MSelect, "pie", hcaes(name = JobFactor, y = percent), name = "Bars") %>% 
   # Optiosn for each type of series
  hc_plotOptions(
    series = list(
      showInLegend = FALSE,
      pointFormat = "{point.y}%"
    ),
    pie = list(
      colorByPoint = TRUE, center = c('30%', '10%'),
      size = 120, dataLabels = list(enabled = FALSE)
    )) %>%
  # Axis
  hc_xAxis(categories = JobFactor.Select$JobFactor) %>%
  #Title & Subtitle
         hc_title(text = "JobFactor")

```
 The Majority learners seems to think that their Job title are a somewat important. Although surprisingly, not all of the learners hold job title in an important place

## Age  {.tabset}

```{r}
hchart(multipleChoiceResponses$Age, na.rm =T)%>%
    hc_title(text = "Age") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="Age", Asked]),"]",
                           eval(schema[Column=="Age", Question])
                           ))
```

As noted by other kernals, most the respondents of the survey are young, most likely in their mid 20s.

```{r}
# highchart() %>%
#   hc_add_series(density(multipleChoiceResponses[!is.na(Age),Age])) %>%
#   hc_xAxis(plotLines = list(
#     list(
#       value = median(multipleChoiceResponses[!is.na(Age),Age]),
#       color = '#ff0000',
#       width = 3,
#       zIndex = 4,
#       label = list(text = paste("Median:", median(multipleChoiceResponses[!is.na(Age),Age])),
#                    style = list( color = '#ff0000', fontWeight = 'bold' )
#       )),
#     list(
#       value = quantile(multipleChoiceResponses[!is.na(Age),Age], 0.75)[[1]],
#       color = '#ff0000',
#       width = 3,
#       zIndex = 4,
#       label = list(text = paste("Q3:", quantile(multipleChoiceResponses[!is.na(Age),Age], 0.75)[[1]]),
#                    style = list( color = '#ff0000', fontWeight = 'bold' )
#       )),
#     list(
#       value = quantile(multipleChoiceResponses[!is.na(Age),Age], 0.25)[[1]],
#       color = '#ff0000',
#       width = 3,
#       zIndex = 4,
#       label = list(text = paste("Q1:", quantile(multipleChoiceResponses[!is.na(Age),Age], 0.25)[[1]]),
#                    style = list( color = '#ff0000', fontWeight = 'bold' )
#       ))))
```

## Career Switcher  {.tabset}

```{r}
hchart(fct_infreq(multipleChoiceResponses$CareerSwitcher), na.rm =T,
       options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
    hc_title(text = "CareerSwitcher") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="CareerSwitcher", Asked]),"]",
                           eval(schema[Column=="CareerSwitcher", Question])
                           ))
```

## Salary Change  {.tabset}

```{r}
hchart(fct_infreq(multipleChoiceResponses$SalaryChange), na.rm =T,
       options3d = list(enabled = TRUE, beta = 1, alpha = 1)) %>%
    hc_title(text = "SalaryChange") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="SalaryChange", Asked]),"]",
                           eval(schema[Column=="SalaryChange", Question])
                           ))


# Extracting all column that cosist of JobFactor string.
SalaryChange.Select <- MultipleChoice_func("SalaryChange")

SalaryChange.MSelect <- SalaryChange.Select %>%
  .[, .(percent=signif(sum(percentage)*100, 3)), by = value]



highchart() %>%   
  hc_add_series(SalaryChange.Select, "column", hcaes(x = value, y = N), name = "column") %>%
  hc_add_series(SalaryChange.MSelect, "pie", hcaes(name = value, y = percent), name = "Bars") %>% 
   # Optiosn for each type of series
  hc_plotOptions(
    series = list(
      showInLegend = FALSE,
      pointFormat = "{point.y}%"
    ),
    column = list(
      colorByPoint = TRUE
    ),
    pie = list(
      colorByPoint = TRUE, center = c('20%', '10%'),
      size = 120, dataLabels = list(enabled = FALSE)
    )) %>%
  # Axis
  hc_xAxis(categories = SalaryChange.Select$value) %>%
  #Title & Subtitle
         hc_title(text = "SalaryChange")

```

Wow, most people saw a 20% increase in salary over 3 years. Guess Data science is indeed a field in demand.



## Remote Work  {.tabset}

```{r}
hchart(multipleChoiceResponses$RemoteWork, na.rm =T)%>%
    hc_title(text = "RemoteWork") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="RemoteWork", Asked]),"]",
                           eval(schema[Column=="RemoteWork", Question])
                           ))
```

## Currency  {.tabset}

Sadly, the conversionRates provided gave only "OriginCountry" (USD, EUR, AUD etc) and "conversionRates"  (in numerics with USD as base line). I find the "OriginCountry" to be somewat misleading, as it is more of a Currency Code than Country.

One will have to relate that to Country Name before joining the ConversionRates into multipleChoiceResponses. The following codes attempts several joins

conversionRates -> currency2CountryName -> multipleChoiceResponses
(where -> = join into ).

```{r}
# # Cleaning up Conversion Rates, removing X which seems to be a raw ID
conversionRates$X=NULL

# # Renaming conversionRates to facillate easier join
colnames(conversionRates) <- c("Code", "ExchangeRate")

# # joining currency2CountryName and conversionRates together
Currency2CountryConversion <- currency2CountryName[conversionRates, on=.(Code)]

# # Converting country code into character
# # Currency2CountryConversion$CountryCode <- as.character(Currency2CountryConversion$CountryCode)
multipleChoiceResponses$CompensationAmount <- as.numeric(as.character(multipleChoiceResponses$CompensationAmount))

# # It seems Currency2CountryConversion has some NA/nonunique value for Country Name and Code
# glimpse(unique(Currency2CountryConversion[is.na(Country)]))
# $ Country      <fctr> NA, NA, NA, NA
# $ CountryCode  <fctr> NA, NA, NA, NA
# $ Currency     <fctr> NA, NA, NA, NA
# $ Code         <fctr> RSD, BAM, BYN, GHS
# $ ExchangeRate <dbl> 0.010020, 0.611383, 0.518071, 0.225710
# # Removing them as this will cause duplicates when merging
Currency2CountryConversion <- Currency2CountryConversion[!is.na(Country)]

# # Combining the main dt with Currency2Country
multipleChoiceResponses <- Currency2CountryConversion[] %>%
  .[multipleChoiceResponses, on=.(Country)] %>%
  # # Create a column that account for the conversion rate of local currencies
  .[!is.na(CompensationAmount), m.CompensationLocal:= CompensationAmount * ExchangeRate]

# # Changing columns into as.character to facillitate comparison for later section
multipleChoiceResponses[, c("Code", "CompensationCurrency"):=lapply(.SD, as.character), .SDcols=c("Code", "CompensationCurrency")]

# class(multipleChoiceResponses$CompensationCurrency)

# Comparison
# unique(multipleChoiceResponses[CompensationCurrency==Code,.(CompensationCurrency, Code)])
```

## Learning Platform Select  {.tabset}
```{r}
schema[Column=="LearningPlatformSelect", Question]

t.WTF <- MultipleChoiceOptions_func("LearningPlatformSelect") 


hchart(t.WTF, type="column", hcaes(x = value, y = N, group = value),
                                   options3d = list(enabled = TRUE, beta = 1, alpha = 1)) %>%
  # title and subtitle
         hc_title(text = "LearningPlatformSelect") %>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="LearningPlatformSelect", Asked]),"]",
                                  eval(schema[Column=="LearningPlatformSelect", Question])
                                  ))


```

## Learning Platform Usefulness  {.tabset}

```{r}
# Extracting values for column plot
Agg_LearningPlatform <- MultipleChoice_func("LearningPlatformUsefulness") 

# Values for spline plot
Avg_LearningPlatform <- Agg_LearningPlatform %>%
  .[value == "Very useful", score := 2] %>%
  .[value == "Somewhat useful", score := 1] %>%
  .[value == "Not Useful", score := 0] %>%
  .[,list(Average = signif(mean(score*N)/mean(N),3)),by=list(LearningPlatformUsefulness)]

# hchart(Agg_LearningPlatform, type="column", hcaes(x = LearningPlatformUsefulness, y = N, group = value), options3d = list(enabled = TRUE, beta = 1, alpha = 1)) %>%
#   # title and subtitle
#          hc_title(text = "LearningPlatformUsefulness") 

# Double y axis highchart
highchart() %>%
  hc_yAxis_multiples(
    list(lineWidth = 3, title = list(text="N")),
    list(showLastLabel = FALSE, opposite = T, title = list(text="Score Out of 2"))
  ) %>%
  hc_add_series(Agg_LearningPlatform, "column", hcaes(x = LearningPlatformUsefulness
                                                      , y = N, group = value)) %>%
  hc_add_series(Avg_LearningPlatform, "spline", hcaes(x = LearningPlatformUsefulness, y = Average), name = "AvgScore",  yAxis = 1) %>%
  hc_xAxis(categories = Avg_LearningPlatform$LearningPlatformUsefulness)%>%
  # title and subtitle
         hc_title(text = "LearningPlatformUsefulness")
```

## Work Tools Frequency  {.tabset}

```{r}
# Extracting values for column plot
Agg_WorkToolsFre  <- MultipleChoice_func("WorkToolsFrequency") 
# hchart(t.WTF, type="column", hcaes(x = WorkToolsFrequency, y = N, group = value))

# Values for spline plot
Avg_WorkToolsFre <- Agg_WorkToolsFre %>%
  .[value == "Often", score := 3] %>%
  .[value == "Most of the time", score := 2] %>%
  .[value == "Sometimes", score := 1] %>%
  .[value == "Rarely", score := 0] %>%
  .[,list(Average = signif(mean(score*N)/mean(N),3)),by=list(WorkToolsFrequency)]

# Double y axis highchart
highchart() %>%
  hc_yAxis_multiples(
    list(lineWidth = 3, title = list(text="N")),
    list(showLastLabel = FALSE, opposite = T, title = list(text="Score Out of 2"))
  ) %>%
  hc_add_series(Agg_WorkToolsFre, "column", hcaes(x = WorkToolsFrequency
                                                      , y = N, group = value)) %>%
  hc_add_series(Avg_WorkToolsFre, "spline", hcaes(x = WorkToolsFrequency, y = Average), name = "AvgScore",  yAxis = 1) %>%
  hc_xAxis(categories = Avg_WorkToolsFre$WorkToolsFrequency)%>%
  # title and subtitle
         hc_title(text = "LearningPlatformUsefulness")
```

## Proving your worth  {.tabset}

### Proven Knowledge Select

```{r}
Select_ProveKnowledge <- MultipleChoice_func("ProveKnowledge") 
## Basic plot
# hchart(Select_ProveKnowledge, type="column", hcaes(x = value, y = N, group = value)) %>%
#   # title and subtitle
#   hc_title(text = "ProveKnowledge") %>%
#   hc_subtitle(text = paste("Q","[",eval(schema[Column=="ProveKnowledgeSelect", Asked]),"]",
#                            eval(schema[Column=="ProveKnowledgeSelect", Question])
#   ))

# highchart
highchart() %>%   
  hc_add_series(Select_ProveKnowledge, "column", hcaes(x = value, y = N), name = "column") %>%
  hc_add_series(Select_ProveKnowledge, "pie", hcaes(name = value, y = percentage), name = "Pie") %>% 
  # Optiosn for each type of series
  hc_plotOptions(
    series = list(
      showInLegend = FALSE,
      pointFormat = "{point.y}%"
    ),
    column = list(
      colorByPoint = TRUE
    ),
    pie = list(
      colorByPoint = TRUE, center = c('30%', '10%'),
      size = 120, dataLabels = list(enabled = FALSE)
    )) %>%
  # Axis
  hc_xAxis(categories = Select_ProveKnowledge$value) %>%
  # Title & Subtitle
  hc_title(text = "ProveKnowledge") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="ProveKnowledgeSelect", Asked]),"]",
                           eval(schema[Column=="ProveKnowledgeSelect", Question])
  ))
```

Evidently, for learners, the majority think that working experience is the most important method to prove their know how of DS/ML. This is followed by Kaggle competitions, Online courses and Github Portfolio. 

I think this selections has limited the respondents to choose only amount the listed choices (ie, bias in that most people could not be bother to select "Other" option). Among the choice I think that are missing from the list are projects, open-sourced packages contributions, blogs and publication

### Proven Knowledge FreeForm

```{r}
# ProveKnowledgeFreeForm
ProveKnowledge_FreeForm <- Wordclourd_func("ProveKnowledgeFreeForm")
wordcloud(ProveKnowledge_FreeForm$term, ProveKnowledge_FreeForm$num, max.words = 100,
           random.order=FALSE, colors=brewer.pal(8,"Dark2"), rot.per=.3, scale=c(3,.5))
```

Its equivalent freeform form of data, however, are overwhelming pointing towards projects. Although limited people proceed to fill the free form data.

## Algorithm Understanding  {.tabset}

```{r}
hchart(multipleChoiceResponses$AlgorithmUnderstandingLevel, na.rm =T)%>%
    hc_title(text = "AlgorithmUnderstandingLevel") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="AlgorithmUnderstandingLevel", Asked]),"]",
                           eval(schema[Column=="AlgorithmUnderstandingLevel", Question])
                           ))
```


## Impactful Algorithm FreeForm  {.tabset}

```{r}
schema[Column=="ImpactfulAlgorithmFreeForm", Question]

# ImpactfulAlgorithmFreeForm
ImpactfulAlgorithm_FreeForm <-  Wordclourd_func("ImpactfulAlgorithmFreeForm")
wordcloud(ImpactfulAlgorithm_FreeForm$term, ImpactfulAlgorithm_FreeForm$num, max.words = 100,
           random.order=FALSE, colors=brewer.pal(8,"Dark2"), rot.per=.3, scale=c(3,.5))

```

# Interesting combination

## Network Graph of Career Change
If we draw a network graph assuming therea connection between past job(s) and current job.

```{r}
# Making sure that this column is in characters
JobNetworkPlot_dt <- multipleChoiceResponses[, PastJobTitlesSelect:=lapply(.SD, as.character ), .SDcols = c("PastJobTitlesSelect") ] %>%
  # Selecting only relevent columns of "CurrentJobTitleSelect" and "PastJobTitlesSelect"
  .[,colnames(.) %in% c("PastJobTitlesSelect", "CurrentJobTitleSelect"), with = FALSE] 

# Determinating the appropriate number of splits
t.splits <- max(lengths(strsplit(JobNetworkPlot_dt$PastJobTitlesSelect, '\\([^)]+,(*SKIP)(*FAIL)|,\\s*', perl = TRUE)))

t.links <- JobNetworkPlot_dt %>%
  # There are respondents that gave a list of previous job titles, yet did not have their current job title recorded, the past job titles select would still hold valueble data. For these people,chanaging their Current JobTitle to "Not Given" 
  .[is.na(CurrentJobTitleSelect), CurrentJobTitleSelect:="Not given"] %>%
  # strsplit the past job title select base on ","
  .[, paste0("m.PastJobTitlesSelect",
             1:t.splits):=tstrsplit(PastJobTitlesSelect,
                                    '\\([^)]+,(*SKIP)(*FAIL)|,\\s*',
                                    perl = TRUE)] %>%
  melt(.,  measure.vars = patterns("^m.*"), na.rm = T) %>%
  # Removing those who arent/ havent start working
  .[!value=="I haven't started working yet"] %>%
  .[,(colnames(.) %in% c("CurrentJobTitleSelect", "value")),with = F] %>%
  .[,list(weight=.N), by = c("CurrentJobTitleSelect", "value")]

t.vertices <- JobNetworkPlot_dt %>%
  # Similar to previous t.link tstrsplit at this point
  .[is.na(CurrentJobTitleSelect), CurrentJobTitleSelect:="Not given"] %>%
  # strsplit the past job title select base on ","
  .[, paste0("m.PastJobTitlesSelect",
             1:t.splits):=tstrsplit(PastJobTitlesSelect,
                                    '\\([^)]+,(*SKIP)(*FAIL)|,\\s*',
                                    perl = TRUE)] %>%
  .[, names(.)!="PastJobTitlesSelect", with =F]%>%
  # splitting all columns into value
  melt(.,  measure.vars = patterns("*"), na.rm = T) %>%
  # Removing those who arent/ havent start working
  .[!value=="I haven't started working yet"] %>%
  .[,list(Frequency=.N), by = value]%>%
  .[,Previous_percent:=signif(Frequency/sum(Frequency)*100,2)]

t.vertices_w_current <- multipleChoiceResponses %>%
  .[is.na(CurrentJobTitleSelect), CurrentJobTitleSelect:="Not given"] %>%
  .[!is.na(CurrentJobTitleSelect),.N, by = CurrentJobTitleSelect ] %>%
  setnames(.,  c("value", "N")) %>%
  .[, value := as.character(value)] %>%
  .[t.vertices, on ="value" ] %>%
  .[,Current_percent:=signif(N/sum(N, na.rm = T)*100,2)]

## Making network list with igraph
net <- graph_from_data_frame(d=t.links, vertices =t.vertices_w_current, directed=T) 
net <- simplify(net, remove.multiple = F, remove.loops = T) 
# plot(net, edge.arrow.size=.4,vertex.label=V(net)$name, vertex.size = 10, edge.width=E(net)$weight/200)
# plot(net, edge.arrow.size=.4,layout=layout_in_circle, edge.width=E(net)$weight/200)

## Auesthetic and details  for hchart/plotting on network
wc <- cluster_walktrap(net)
V(net)$comm <- membership(wc)
V(net)$color <- colorize(membership(wc))
# V(net)$betweenness <- betweenness(net)
# V(net)$color <- colorize(V(net)$betweenness)
# V(net)$degree <- degree(net)
V(net)$size <- V(net)$Frequency
V(net)$label <- V(net)$name
E(net)$width <- E(net)$weight/250
E(net)$arrow.size <- 15 

hchart(net, layout = layout_with_fr)
```


## Non Coders & Job Title

```{r}
Agg_CoderJob<-multipleChoiceResponses[!is.na(CurrentJobTitleSelect) & !is.na(CodeWriter)] %>%
  .[, .N, by=.(CurrentJobTitleSelect, CodeWriter)] %>%
  .[order(-N)]

hchart(Agg_CoderJob, type="column", hcaes(x = CurrentJobTitleSelect, y = N, group = CodeWriter)) %>%
hc_title(text = "Coders with relation to Job Title") 

```

Well, it seems close to half of the Software Enginer dont write codes? That's a bit strange.

In case for Business Analyst and Data Analyst, the amount of non coders could maybe be attributed to their dealing with other statistical software. Perhaps some of the jobs still involve around good old excel.


### Non Coders and their career


```{r}
# Typically, we are restricted to 3 dimensional plots, x, y, group. 
# though, there are also the paste-combine trick
NonCodersTitle<-c("Software Developer/Software Engineer", "Business Analyst", "Programmer")

t.WTF <- multipleChoiceResponses %>%
  .[!is.na(CurrentJobTitleSelect) & !is.na(m.Experience)] %>%
  # Selecting only NoncodersTitle
  .[CurrentJobTitleSelect %in% NonCodersTitle ] %>%
  .[, Combined:=paste(CurrentJobTitleSelect,"-", m.Experience)] %>%
  .[, .N, by=.(Combined, CodeWriter, m.Experience)] %>%
  .[order(m.Experience, Combined, CodeWriter)] 

hchart(t.WTF, type="bar", hcaes(x = Combined, y = N, group = CodeWriter)) %>%
  # hc_xAxis(labels = list(rotation=90)) %>%
  hc_title(text = "Jobs with significant coders differentiate by Experience") %>%
  hc_subtitle(text="Coders (Yes/No) ; the length of Tenure is indicated by the median number after the job title.")

```

In both three case, it seems that some Business Analyst, Programmers and Software engineer entry level jobs does not require the entrant to be coders. There exist a significant amount of non coders in these jobs. However, it seems that those with more working experience in these field do write codes.

It seems that these professions are good staging ground for those who are intending venture into Data Science for those who are weak on the codes/programming side. Especially if you are from another field. Although, from what I seen (in Asia) , those Business Analyst roles typically require finance/business background instead of science.

On the other hand, the fabled "manager role" that dont require coding is elusive.

## Country vs Compensation Currency, Compensation Amount

```{r}

# Turning CompensationAmountfrom factor into numeric column
multipleChoiceResponses$CompensationAmount <- as.numeric(as.character(multipleChoiceResponses$CompensationAmount))

# Create duplicate columns of original to allow manipulation
multipleChoiceResponses$m.CompensationAmount <- multipleChoiceResponses$CompensationAmount
multipleChoiceResponses$m.CompensationCurrency <- multipleChoiceResponses$CompensationCurrency

# From the quantile value (Q1 - Q3) in this case, I think one can safetly assume that the salary of those living in US can be changed to USD.
multipleChoiceResponses[Country=="United States" & 
                          !is.na(CompensationAmount),
                        list(.N, 
                             Median=median(CompensationAmount),
                             Q1=quantile(CompensationAmount, 0.25),
                             Q3=quantile(CompensationAmount, 0.75)
                        ), by=CompensationCurrency] %>%
  .[N>5]

# Change the Compensation Currency of those living in US yet did not select a currency into USD.
multipleChoiceResponses[!is.na(CompensationAmount) & 
                          is.na(CompensationCurrency) &
                          Country=="United States", 
                        m.CompensationCurrency:="USD"]

# Converting all curruncies to USD to ease comparison between different currencies
multipleChoiceResponses<-multipleChoiceResponses[!is.na(CompensationAmount) &
                                                   !is.na(ExchangeRate),
                                                 m.CompensationUSD := m.CompensationAmount*ExchangeRate] %>%
  # Adapting partial ikleiman's treatment of salary, where if the salary is between 6 and 36 times of the median, it is assumed that the respondant entered a monthly salary, hence, * 12
      # https://www.kaggle.com/ikleiman/data-scientists-salaries-around-the-world
  .[CompensationAmount >= median(CompensationAmount)/36 & 
      CompensationAmount < median(CompensationAmount)/6,
    ':='(m.CompensationAmount = CompensationAmount*12,
         m.CompensationUSD = CompensationAmount*ExchangeRate*12), 
    by = Country] 
  

```

## Individuals Earnings distribution in USD per Country

```{r}
Individual_Earning.dt <- multipleChoiceResponses %>%
  .[, names(.) %in% c("m.CompensationUSD","EmploymentStatus", "Country"), with = F] %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationUSD) &
      !m.CompensationUSD==0 &
      EmploymentStatus == "Employed full-time"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  # .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[order(Country)] %>%
  # .[, if(.N > 10) .SD, by=c("Country")] %>%
  .[,':='(q95= quantile(m.CompensationUSD, 0.95),
          med= median(m.CompensationUSD),
          q5 = quantile(m.CompensationUSD, 0.05)), by = Country]%>%
  .[m.CompensationUSD<q95, ] %>%
  .[m.CompensationUSD>q5, ]  %>%
.[order(-med)]

# plot of hcboxplot
hcboxplot(x = Individual_Earning.dt$m.CompensationUSD, var = Individual_Earning.dt$Country) %>%
  hc_xAxis(labels = list(rotation=0)) %>%
  hc_yAxis(title = list(text="USD")) %>%
  hc_title(text = "Boxplot of m.CompensationUSD per country") 
```

### Number of Individuals earning Foreign Currencies

```{r}
# There exist individuals who are taking foreign currency, perhaps they are doing remote work or working overseas? 
Foreign.dt<-multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & !is.na(m.CompensationCurrency)] %>%
  # Filtering cases where the CompensationCurrency isn't identical with the Country Currency
  .[CompensationCurrency!= Code] %>%
  .[, .N, by = list(Country)] %>%
  .[order(-N)] 

highchart() %>%
  hc_add_series(Foreign.dt, "column", hcaes(x = Country, y = N)) %>%
  hc_xAxis(categories =Foreign.dt$Country) %>%
  hc_title(text = "Foreign Currencies Compensation") %>%
  hc_subtitle(text = "Number of survey respondents earning foreign currencies, all of their compensation currency is listed to be in USD")

## Bootstrep to check the std.error in mean of different groups
# stat<-function(x, i) {x[i, c(m1 = mean(CompensationAmount))]}
# where<-tempt[, list(list(boot(.SD, stat, R = 10))), by = CompensationCurrency]
# where$V1

```

## Pay Package

In this section, we restrict ourselves to those living in US to look at their pay and growth

### Experience Growth

```{r}
# multipleChoiceResponses$m.CompensationAmount
multipleChoiceResponses[Tenure =="Less than a year", Tenure:="0 Less than a year" ] 

# 
dt.ExpGrowth <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[,list(.N, 
          Median=median(m.CompensationAmount),
          Q1=quantile(m.CompensationAmount, 0.25),
          Q3=quantile(m.CompensationAmount, 0.75)
  ), by =list(Tenure, m.Experience)] %>%
  .[order(m.Experience)]

# c("Less than a year", "1 to 2 years", "3 to 5 years", "6 to 10 years", "More than 10 years", "I don't write code to analyze data")
# unique(multipleChoiceResponses$EmploymentStatus)

t.WTF <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & CompensationCurrency=="USD" & !CompensationAmount==0 & EmploymentStatus == "Employed full-time"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  # .[, if(.N > 5) .SD, by=c("Tenure")] %>%
  .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[,':='(q95= quantile(m.CompensationUSD, 0.95),
          med= median(m.CompensationUSD),
          q5 = quantile(m.CompensationUSD, 0.05)), by = Tenure] %>%
  .[m.CompensationUSD<q95, ] %>%
  .[m.CompensationUSD>q5, ]

# highchart
hcboxplot(x = t.WTF$m.CompensationAmount, var = t.WTF$Tenure) %>% 
  hc_chart(type = "column")  %>%# to put box vertical
  hc_title(text = "Jobs Wages per Experience") %>%
  hc_subtitle(text = "To facilitate a fair comparison, the figures are drawn only from those fully employed in US, along with trimming of 5% and 95% of the distribution") 
```

### Experience & Education

It seems only reasonable to restrict pay packages to individual country (or cities) and local currency.


```{r}
multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[,list(.N, 
          Median=median(m.CompensationAmount),
          Q1=quantile(m.CompensationAmount, 0.25),
          Q3=quantile(m.CompensationAmount, 0.75)
          ), by =list(Tenure, FormalEducation)] %>%
  .[order(FormalEducation,Tenure)]


t.WTF <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & 
      CompensationCurrency=="USD" &
      !m.CompensationAmount==0 &
      EmploymentStatus == "Employed full-time" &
      Country=="United States"] %>%
  # Additional filtering, removing some educational levels
  .[!FormalEducation %in% c("I did not complete any formal education past high school", 
                            "I prefer not to answer", 
                            NA),] %>%
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[order(Tenure)] %>%
  .[, if(.N > 5) .SD, by=c("Tenure", "m.Experience")]%>%
 .[,':='(q95= quantile(m.CompensationUSD, 0.95),
          med= median(m.CompensationUSD),
          q5 = quantile(m.CompensationUSD, 0.05)), by = c("Tenure","FormalEducation")]%>%
  .[m.CompensationUSD<q95, ] %>%
  .[m.CompensationUSD>q5, ] 

# plot of hcboxplot
hcboxplot(x = t.WTF$m.CompensationAmount, var = t.WTF$Tenure, var2 = t.WTF$FormalEducation,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # vertical plot

```

With regards to education, the level of education for "I did not complete any formal education past high school", "I prefer not to answer" and "NA" is filtered from the plot. All these levels have limited entries

In the case of "without formal education past high school", there is only a single data point at 6-10 years of experience while making $150k PA.

### Experience & Job Title

Salary with respect to job title and tenure

```{r}
# limiting to top 5 most popular job title
PopularJob <- head(AggrJobTitle$CurrentJobTitleSelect,10)

multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD" & !is.na(Tenure)] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[CurrentJobTitleSelect %in% PopularJob,] %>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by =list(Tenure, CurrentJobTitleSelect)] %>%
  .[order(CurrentJobTitleSelect, Tenure)]


t.WTF <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & 
      CompensationCurrency=="USD" &
      !m.CompensationAmount==0 &
      EmploymentStatus == "Employed full-time" &
      Country=="United States"] %>%
  # Additional filtering for popular jobs
  .[CurrentJobTitleSelect %in% PopularJob,] %>%
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[order(Tenure)] %>%
  .[, if(.N > 5) .SD, by=c("Tenure", "m.Experience")]%>%
 .[,':='(q95= quantile(m.CompensationUSD, 0.95),
          med= median(m.CompensationUSD),
          q5 = quantile(m.CompensationUSD, 0.05)), by = c("Tenure","CurrentJobTitleSelect")]%>%
  .[m.CompensationUSD<q95, ] %>%
  .[m.CompensationUSD>q5, ] 


# plot of hcboxplot
hcboxplot(x = t.WTF$m.CompensationAmount, var = t.WTF$Tenure, var2 = t.WTF$CurrentJobTitleSelect,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # to put box vertical
```

### Currency & Remote work

Having combined the the compensation currency and currency code for supposed country that the respondents are living, I wonder if all these people who are receiving foreign currency were doing mostly remove work?

Remote can also be related to cloud technologies such as spark, hadoop, AWS. It is likely also essential if one have to deal with big data regularly (over 1TB).


```{r}
multipleChoiceResponses[,.N,by=c("JobSkillImportanceBigData", "RemoteWork")]
```

```{r}
schema[Column=="RemoteWork"]$Question
# multipleChoiceResponses$JobSkillImportanceBigData
# multipleChoiceResponses$WorkCodeSharing
# multipleChoiceResponses$WorkDataSharing


# t.WTF<-multipleChoiceResponses[!is.na(CompensationCurrency)& 
#                                  CompensationCurrency!= Code &
#                                  !is.na(RemoteWork) & 
#                                  Country=="United States",
#                                list(N=.N,
#                                     MedPay=median(m.CompensationUSD)), 
#                                by=c("RemoteWork", "Tenure")] %>%
#   .[order(-RemoteWork)]
# 
# 
# 
# t.WTF<-multipleChoiceResponses[!is.na(RemoteWork) & !is.na(Tenure) & Country=="United States",
#                                list(N=.N,
#                                     MedPay=median(m.CompensationUSD, na.rm = T)), 
#                                by=c("RemoteWork", "Tenure")] %>%
#   .[order(Tenure)]


t.WTF <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & 
      m.CompensationCurrency=="USD" &
      !m.CompensationAmount==0 &
      EmploymentStatus == "Employed full-time" &
      !is.na(RemoteWork) &
      Country=="United States"] %>%
  # Additional filtering for popular jobs
  .[CurrentJobTitleSelect %in% PopularJob,] %>%
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[order(Tenure)] %>%
  .[, if(.N > 5) .SD, by=c("Tenure")] %>%
  .[,':='(q95= quantile(m.CompensationUSD, 0.95),
          med= median(m.CompensationUSD),
          q5 = quantile(m.CompensationUSD, 0.05)), by = c("Tenure","RemoteWork")]%>%
  .[m.CompensationUSD<q95, ] %>%
  .[m.CompensationUSD>q5, ] 

# plot of hcboxplot
hcboxplot(x = t.WTF$m.CompensationAmount, var = t.WTF$Tenure, var2 = t.WTF$RemoteWork,
          outliers = FALSE) %>% 
  hc_chart(type = "column") %>% # to put box vertical
hc_title(text = "Currency & Remote work") 

# hchart(t.WTF, type="column", hcaes(x = Tenure, y = m.CompensationUSD, group = RemoteWork)) %>%
# hc_title(text = "Currency & Remote work") 


```
## Choropleths Map

### Currency Codes & Country Name & highcharter Map

```{r}
#loading world-geojson that is part of highcharter
data(worldgeojson)

#plotting for highcharter map
hcmap(mapData = worldgeojson, 
      download_map_data=F, data = Currency2CountryConversion, value = "ExchangeRate",
      joinBy = c("iso-a2", "CountryCode"), name = "Demography",
      dataLabels = list(enabled = F, format = '{point.name}'), borderWidth = 1,
      tooltip = list(valueDecimals = 2, valuePrefix = "$", valueSuffix = " USD")) 
```


```{r}
multipleChoiceResponses %>%
  .[Country=="Australia", CountryCode:= "AU"]%>%
  .[Country=="Russia", CountryCode:= "RS"] %>%
  .[Country=="South Korea", CountryCode:="KR"] %>%
  .[Country=="Iran", CountryCode:="IR"]%>%
  .[Country=="Belarus", CountryCode:="BR"]

# Aggregate the demographics for countries
t.cut<-multipleChoiceResponses[!is.na(Country),] %>%
  .[,.(NCount=.N, 
        AgeMedian = as.numeric(median(Age, na.rm=T)),
        CareerSwitcherP=signif(as.numeric(mean(CareerSwitcher=="Yes", na.rm=T)),2),
       WorkingP=signif(mean(EmploymentStatus=="Employed full-time"|
                       EmploymentStatus=="Independent contractor, freelancer, or self-employed"|EmploymentStatus=="Employed part-time", na.rm=T),2),
       LookingForJobP=signif(mean(EmploymentStatus=="Not employed, but looking for work", na.rm=T),1),
       StudentP=signif(mean(StudentStatus=="Yes", na.rm=T),2),
       WorkingExpMedian= signif(median(m.Experience, na.rm = T),2)
   ), 
   by=c("CountryCode", "Country")]
      
# Plotting for highcharter map
hcmap(mapData = worldgeojson, 
      download_map_data=F, data = t.cut, value = "NCount",
      joinBy = c("iso-a2", "CountryCode"), name = "Demography",
      dataLabels = list(enabled = F, format = '{point.name}'), borderWidth = 1) %>%
hc_tooltip(useHTML = TRUE,
             headerFormat = "<table>",
             pointFormat = paste("<tr><th colspan=\"1\"><td>{point.Country}</td></th></tr>",
                                 "<tr><th>NCount<td>{point.NCount}</td></th></tr>",
                                 "<tr><th>AgeMedian</th><td>{point.AgeMedian}</td></tr>",
                                 "<tr><th>WorkingP</th><td>{point.WorkingP}</td></tr>",
                                 "<tr><th>CareerSwitcherP</th><td>{point.CareerSwitcherP}</td></tr>",
                                 "<tr><th>LookingForJobP</th><td>{point.LookingForJobP}</td></tr>",
                               "<tr><th>WorkingExpMedian</th><td>{point.WorkingExpMedian}</td></tr>"),
             footerFormat = "</table>")

```
