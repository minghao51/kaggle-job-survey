---
title: "kaggle-survey 2017"
date: "November 09, 2017"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    df_print: paged
    number_sections: yes
    code_folding: hide
---


```{r}
# disable floating TOC for kaggle submission
# toc_float: true
```

# Libraries

```{r, warning = FALSE, message=FALSE}
#general
library(purrr)
require(tidyverse)
require(data.table)
require(lubridate)
require(stringr)
require(ggvis)
require(ggplot2)
require(forcats)
require(ggmap)
require(highcharter)
require(broom)
require(plotly)


#NLP
require(quanteda)
require(wordcloud)
require(slam) # to facilliate row_sums with sparse matrix

#map
require(leaflet)

#network plot
require(igraph)
```

* Note that I made extensive use of data.table packages instead of dplyr to extract, filter, process the data as it's the method that I'm most conformable with.

* The majority ( of not all the plots) are done with highcharter.

* Quanteda stem completion and tokenisation, while fast, seems slightly less flexible than those of tm/snowball package. 

<br/>
<hr/>
<br/>

# Data Input

The .csv are data provided by Kaggle that includes a seperate .csv file for 

* Conversion Rates ( with origin Country and exchange Rate)
* freeformResponse ( For survey questions that accepted freeform inputs)
* multipleChoiceResponse ( For survey questions that a list of selections are given ( sometimes multiple selections are accepted)

```{r}
#input for various csv files.

# conversionRates <- as.data.table(read.csv(file="../input/conversionRates.csv",strip.white = TRUE, 
#                                           na.strings=c("","NA"), 
#                                           stringsAsFactors = FALSE))
# multipleChoiceResponses <- as.data.table(read.csv(file="../input/multipleChoiceResponses.csv",
#                                           strip.white = TRUE, 
#                                           na.strings=c("","NA"), 
#                                           stringsAsFactors = FALSE))
# freeformResponses <- as.data.table(read.csv(file="../input/freeformResponses.csv",
#                                           strip.white = TRUE, 
#                                           na.strings=c("","NA"), 
#                                           stringsAsFactors = FALSE))
# schema <- as.data.table(read.csv(file="../input/schema.csv",
#                                           strip.white = TRUE, 
#                                           na.strings=c("","NA"), 
#                                           stringsAsFactors = FALSE))
# 
conversionRates <- as.data.table(read.csv(file="input/conversionRates.csv", strip.white = TRUE,
                             na.strings=c("","NA"),
                             stringsAsFactors = FALSE))


freeformResponses <- as.data.table(read.csv(file="input/freeformResponses.csv", strip.white = TRUE,
                             na.strings=c("","NA"),
                             stringsAsFactors = FALSE))

multipleChoiceResponses <- as.data.table(read.csv(file="input/multipleChoiceResponses.csv", strip.white = TRUE,
                             na.strings=c("","NA"),
                             stringsAsFactors = TRUE))

schema <- as.data.table(read.csv(file="input/schema.csv", strip.white = TRUE,
                             na.strings=c("","NA"),
                             stringsAsFactors = FALSE))

```

I also used a Country-Currency-Code list from github, as some of the analysis required country to currency mapping( to determine foreign currencies). Also, the Country Names in the given .csv are mapped to iso2 for plotting in hmap ( highchart's map).

```{r}
## Rcurl into data method
# library(RCurl)
# x <- getURL("https://gist.githubusercontent.com/marcusbaguley/304261/raw/0ab501897ce32fcd3aecd748b74686a20ada9036/Country%2520Currency%2520Code%2520Mappings")
# y <- read.csv(text = x)

## Reading downloaded csv method
# currency2CountryName <- data.table(read.csv("Country Currency Code Mappings.csv"))

# dput(droplevels(currency2CountryName[, lapply(.SD, as.character)]))
```

Raw dput input to get currency2CountryName into Kaggle

```{r}
currency2CountryName <-structure(list(Country = c("New Zealand", "Cook Islands", "Niue", 
"Pitcairn", "Tokelau", "Australian", "Christmas Island", "Cocos (Keeling) Islands", 
"Heard and Mc Donald Islands", "Kiribati", "Nauru", "Norfolk Island", 
"Tuvalu", "American Samoa", "Andorra", "Austria", "Belgium", 
"Finland", "France", "French Guiana", "French Southern Territories", 
"Germany", "Greece", "Guadeloupe", "Ireland", "Italy", "Luxembourg", 
"Martinique", "Mayotte", "Monaco", "Netherlands", "Portugal", 
"Reunion", "Samoa", "San Marino", "Slovenia", "Spain", "Vatican City State (Holy See)", 
"South Georgia and the South Sandwich Islands", "United Kingdom", 
"Jersey", "British Indian Ocean Territory", "Guam", "Marshall Islands", 
"Micronesia Federated States of", "Northern Mariana Islands", 
"Palau", "Puerto Rico", "Turks and Caicos Islands", "United States", 
"United States Minor Outlying Islands", "Virgin Islands (British)", 
"Virgin Islands (US)", "Hong Kong", "Canada", "Japan", "Afghanistan", 
"Albania", "Algeria", "Anguilla", "Antigua and Barbuda", "Dominica", 
"Grenada", "Montserrat", "Saint Kitts", "Saint Lucia", "Saint Vincent Grenadines", 
"Argentina", "Armenia", "Aruba", "Netherlands Antilles", "Azerbaijan", 
"Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belarus", "Belize", 
"Benin", "Burkina Faso", "Guinea-Bissau", "Ivory Coast", "Mali", 
"Niger", "Senegal", "Togo", "Bermuda", "Bhutan", "India", "Bolivia", 
"Botswana", "Bouvet Island", "Norway", "Svalbard and Jan Mayen Islands", 
"Brazil", "Brunei Darussalam", "Bulgaria", "Burundi", "Cambodia", 
"Cameroon", "Central African Republic", "Chad", "Congo Republic of the Democratic", 
"Equatorial Guinea", "Gabon", "Cape Verde", "Cayman Islands", 
"Chile", "China", "Colombia", "Comoros", "Congo-Brazzaville", 
"Costa Rica", "Croatia (Hrvatska)", "Cuba", "Cyprus", "Czech Republic", 
"Denmark", "Faroe Islands", "Greenland", "Djibouti", "Dominican Republic", 
"East Timor", "Indonesia", "Ecuador", "Egypt", "El Salvador", 
"Eritrea", "Ethiopia", "Estonia", "Falkland Islands (Malvinas)", 
"Fiji", "French Polynesia", "New Caledonia", "Wallis and Futuna Islands", 
"Gambia", "Georgia", "Gibraltar", "Guatemala", "Guinea", "Guyana", 
"Haiti", "Honduras", "Hungary", "Iceland", "Iran (Islamic Republic of)", 
"Iraq", "Israel", "Jamaica", "Jordan", "Kazakhstan", "Kenya", 
"Korea North", "Korea South", "Kuwait", "Kyrgyzstan", "Lao PeopleÃ.s Democratic Republic", 
"Latvia", "Lebanon", "Lesotho", "Liberia", "Libyan Arab Jamahiriya", 
"Liechtenstein", "Switzerland", "Lithuania", "Macau", "Macedonia", 
"Madagascar", "Malawi", "Malaysia", "Maldives", "Malta", "Mauritania", 
"Mauritius", "Mexico", "Moldova Republic of", "Mongolia", "Morocco", 
"Western Sahara", "Mozambique", "Myanmar", "Namibia", "Nepal", 
"Nicaragua", "Nigeria", "Oman", "Pakistan", "Panama", "Papua New Guinea", 
"Paraguay", "Peru", "Philippines", "Poland", "Qatar", "Romania", 
"Russian Federation", "Rwanda", "Sao Tome and Principe", "Saudi Arabia", 
"Seychelles", "Sierra Leone", "Singapore", "Slovakia (Slovak Republic)", 
"Solomon Islands", "Somalia", "South Africa", "Sri Lanka", "Sudan", 
"Suriname", "Swaziland", "Sweden", "Syrian Arab Republic", "Taiwan", 
"Tajikistan", "Tanzania", "Thailand", "Tonga", "Trinidad and Tobago", 
"Tunisia", "Turkey", "Turkmenistan", "Uganda", "Ukraine", "United Arab Emirates", 
"Uruguay", "Uzbekistan", "Vanuatu", "Venezuela", "Vietnam", "Yemen", 
"Zambia", "Zimbabwe"), CountryCode = c("NZ", "CK", "NU", "PN", 
"TK", "AU", "CX", "CC", "HM", "KI", "NR", "NF", "TV", "AS", "AD", 
"AT", "BE", "FI", "FR", "GF", "TF", "DE", "GR", "GP", "IE", "IT", 
"LU", "MQ", "YT", "MC", "NL", "PT", "RE", "WS", "SM", "SI", "ES", 
"VA", "GS", "GB", "JE", "IO", "GU", "MH", "FM", "MP", "PW", "PR", 
"TC", "US", "UM", "VG", "VI", "HK", "CA", "JP", "AF", "AL", "DZ", 
"AI", "AG", "DM", "GD", "MS", "KN", "LC", "VC", "AR", "AM", "AW", 
"AN", "AZ", "BS", "BH", "BD", "BB", "BY", "BZ", "BJ", "BF", "GW", 
"CI", "ML", "NE", "SN", "TG", "BM", "BT", "IN", "BO", "BW", "BV", 
"NO", "SJ", "BR", "BN", "BG", "BI", "KH", "CM", "CF", "TD", "CG", 
"GQ", "GA", "CV", "KY", "CL", "CN", "CO", "KM", "CD", "CR", "HR", 
"CU", "CY", "CZ", "DK", "FO", "GL", "DJ", "DO", "TP", "ID", "EC", 
"EG", "SV", "ER", "ET", "EE", "FK", "FJ", "PF", "NC", "WF", "GM", 
"GE", "GI", "GT", "GN", "GY", "HT", "HN", "HU", "IS", "IR", "IQ", 
"IL", "JM", "JO", "KZ", "KE", "KP", "KR", "KW", "KG", "LA", "LV", 
"LB", "LS", "LR", "LY", "LI", "CH", "LT", "MO", "MK", "MG", "MW", 
"MY", "MV", "MT", "MR", "MU", "MX", "MD", "MN", "MA", "EH", "MZ", 
"MM", NA, "NP", "NI", "NG", "OM", "PK", "PA", "PG", "PY", "PE", 
"PH", "PL", "QA", "RO", "RU", "RW", "ST", "SA", "SC", "SL", "SG", 
"SK", "SB", "SO", "ZA", "LK", "SD", "SR", "SZ", "SE", "SY", "TW", 
"TJ", "TZ", "TH", "TO", "TT", "TN", "TR", "TM", "UG", "UA", "AE", 
"UY", "UZ", "VU", "VE", "VN", "YE", "ZM", "ZW"), Currency = c("New Zealand Dollars", 
"New Zealand Dollars", "New Zealand Dollars", "New Zealand Dollars", 
"New Zealand Dollars", "Australian Dollars", "Australian Dollars", 
"Australian Dollars", "Australian Dollars", "Australian Dollars", 
"Australian Dollars", "Australian Dollars", "Australian Dollars", 
"Euros", "Euros", "Euros", "Euros", "Euros", "Euros", "Euros", 
"Euros", "Euros", "Euros", "Euros", "Euros", "Euros", "Euros", 
"Euros", "Euros", "Euros", "Euros", "Euros", "Euros", "Euros", 
"Euros", "Euros", "Euros", "Euros", "Sterling", "Sterling", "Sterling", 
"USD", "USD", "USD", "USD", "USD", "USD", "USD", "USD", "USD", 
"USD", "USD", "USD", "HKD", "Canadian Dollar", "Japanese Yen", 
"Afghani", "Lek", "Algerian Dinar", "East Caribbean Dollar", 
"East Caribbean Dollar", "East Caribbean Dollar", "East Caribbean Dollar", 
"East Caribbean Dollar", "East Caribbean Dollar", "East Caribbean Dollar", 
"East Caribbean Dollar", "Peso", "Dram", "Netherlands Antilles Guilder", 
"Netherlands Antilles Guilder", "Manat", "Bahamian Dollar", "Bahraini Dinar", 
"Taka", "Barbadian Dollar", "Belarus Ruble", "Belizean Dollar", 
"CFA Franc BCEAO", "CFA Franc BCEAO", "CFA Franc BCEAO", "CFA Franc BCEAO", 
"CFA Franc BCEAO", "CFA Franc BCEAO", "CFA Franc BCEAO", "CFA Franc BCEAO", 
"Bermudian Dollar", "Indian Rupee", "Indian Rupee", "Boliviano", 
"Pula", "Norwegian Krone", "Norwegian Krone", "Norwegian Krone", 
"Brazil", "Bruneian Dollar", "Lev", "Burundi Franc", "Riel", 
"CFA Franc BEAC", "CFA Franc BEAC", "CFA Franc BEAC", "CFA Franc BEAC", 
"CFA Franc BEAC", "CFA Franc BEAC", "Escudo", "Caymanian Dollar", 
"Chilean Peso", "Yuan Renminbi", "Peso", "Comoran Franc", "Congolese Frank", 
"Costa Rican Colon", "Croatian Dinar", "Cuban Peso", "Cypriot Pound", 
"Koruna", "Danish Krone", "Danish Krone", "Danish Krone", "Djiboutian Franc", 
"Dominican Peso", "Indonesian Rupiah", "Indonesian Rupiah", "Sucre", 
"Egyptian Pound", "Salvadoran Colon", "Ethiopian Birr", "Ethiopian Birr", 
"Estonian Kroon", "Falkland Pound", "Fijian Dollar", "CFP Franc", 
"CFP Franc", "CFP Franc", "Dalasi", "Lari", "Gibraltar Pound", 
"Quetzal", "Guinean Franc", "Guyanaese Dollar", "Gourde", "Lempira", 
"Forint", "Icelandic Krona", "Iranian Rial", "Iraqi Dinar", "Shekel", 
"Jamaican Dollar", "Jordanian Dinar", "Tenge", "Kenyan Shilling", 
"Won", "Won", "Kuwaiti Dinar", "Som", "Kip", "Lat", "Lebanese Pound", 
"Loti", "Liberian Dollar", "Libyan Dinar", "Swiss Franc", "Swiss Franc", 
"Lita", "Pataca", "Denar", "Malagasy Franc", "Malawian Kwacha", 
"Ringgit", "Rufiyaa", "Maltese Lira", "Ouguiya", "Mauritian Rupee", 
"Peso", "Leu", "Tugrik", "Dirham", "Dirham", "Metical", "Kyat", 
"Dollar", "Nepalese Rupee", "Cordoba Oro", "Naira", "Sul Rial", 
"Rupee", "Balboa", "Kina", "Guarani", "Nuevo Sol", "Peso", "Zloty", 
"Rial", "Leu", "Ruble", "Rwanda Franc", "Dobra", "Riyal", "Rupee", 
"Leone", "Dollar", "Koruna", "Solomon Islands Dollar", "Shilling", 
"Rand", "Rupee", "Dinar", "Surinamese Guilder", "Lilangeni", 
"Krona", "Syrian Pound", "Dollar", "Tajikistan Ruble", "Shilling", 
"Baht", "PaÃ.anga", "Trinidad and Tobago Dollar", "Tunisian Dinar", 
"Lira", "Manat", "Shilling", "Hryvnia", "Dirham", "Peso", "Som", 
"Vatu", "Bolivar", "Dong", "Rial", "Kwacha", "Zimbabwe Dollar"
), Code = c("NZD", "NZD", "NZD", "NZD", "NZD", "AUD", "AUD", 
"AUD", "AUD", "AUD", "AUD", "AUD", "AUD", "EUR", "EUR", "EUR", 
"EUR", "EUR", "EUR", "EUR", "EUR", "EUR", "EUR", "EUR", "EUR", 
"EUR", "EUR", "EUR", "EUR", "EUR", "EUR", "EUR", "EUR", "EUR", 
"EUR", "EUR", "EUR", "EUR", "GBP", "GBP", "GBP", "USD", "USD", 
"USD", "USD", "USD", "USD", "USD", "USD", "USD", "USD", "USD", 
"USD", "HKD", "CAD", "JPY", "AFN", "ALL", "DZD", "XCD", "XCD", 
"XCD", "XCD", "XCD", "XCD", "XCD", "XCD", "ARS", "AMD", "ANG", 
"ANG", "AZN", "BSD", "BHD", "BDT", "BBD", "BYR", "BZD", "XOF", 
"XOF", "XOF", "XOF", "XOF", "XOF", "XOF", "XOF", "BMD", "INR", 
"INR", "BOB", "BWP", "NOK", "NOK", "NOK", "BRL", "BND", "BGN", 
"BIF", "KHR", "XAF", "XAF", "XAF", "XAF", "XAF", "XAF", "CVE", 
"KYD", "CLP", "CNY", "COP", "KMF", "CDF", "CRC", "HRK", "CUP", 
"CYP", "CZK", "DKK", "DKK", "DKK", "DJF", "DOP", "IDR", "IDR", 
"ECS", "EGP", "SVC", "ETB", "ETB", "EEK", "FKP", "FJD", "XPF", 
"XPF", "XPF", "GMD", "GEL", "GIP", "GTQ", "GNF", "GYD", "HTG", 
"HNL", "HUF", "ISK", "IRR", "IQD", "ILS", "JMD", "JOD", "KZT", 
"KES", "KPW", "KRW", "KWD", "KGS", "LAK", "LVL", "LBP", "LSL", 
"LRD", "LYD", "CHF", "CHF", "LTL", "MOP", "MKD", "MGA", "MWK", 
"MYR", "MVR", "MTL", "MRO", "MUR", "MXN", "MDL", "MNT", "MAD", 
"MAD", "MZN", "MMK", "NAD", "NPR", "NIO", "NGN", "OMR", "PKR", 
"PAB", "PGK", "PYG", "PEN", "PHP", "PLN", "QAR", "RON", "RUB", 
"RWF", "STD", "SAR", "SCR", "SLL", "SGD", "SKK", "SBD", "SOS", 
"ZAR", "LKR", "SDG", "SRD", "SZL", "SEK", "SYP", "TWD", "TJS", 
"TZS", "THB", "TOP", "TTD", "TND", "TRY", "TMT", "UGX", "UAH", 
"AED", "UYU", "UZS", "VUV", "VEF", "VND", "YER", "ZMK", "ZWD"
)), .Names = c("Country", "CountryCode", "Currency", "Code"), row.names = c(NA, 
-232L), class = c("data.table", 
"data.frame"))
```

<br/>
<hr/>
<br/>

# Custom Functions

Some custom function to ease the extraction of data, inspired by [AmberThomas](https://www.kaggle.com/amberthomas/kaggle-2017-survey-results) functions ( which I adapted the some of the regexp treatments. The three different functions are to 

* MultipleChoice_func : To aggregate and summarise column in multipleChoiceResponses.csv that follows certain pattern. For example, multipleChoiceResponses(Country) would output a list of country with aggregated counts. Also, the input will be melted into long format while aggregatation to various factor as in the case multipleChoiceResponses(Jobfactor) in which case there is multiple columns of JobFactorCommute, JobFactorCompanyFunding etc 

* MultipleChoiceOptions_func : For survey questions that accept multiple selections, since these columns require strsplit treatment before aggregation and summarising as the contents are stored in comma separated list. Ie, MultipleChoiceOptions_func(PastJobTitlesSelect)

* Wordclourd_func: applying dfm(quanteda) treatment on the freeformresponses related column to generated a wordfrequency df.


```{r}
# To extract the patterns of response that would follow a similar pattern on counts per value
MultipleChoice_func = function(question, dt = multipleChoiceResponses){
  
  setDT(dt) %>%
    # since the dt contained column with similar name, selecting only these column
    .[, colnames(.) %like% question, with=FALSE] %>%
    # melting wide data into long data
    melt(.,measure.vars=patterns(question), na.rm = TRUE, variable.name=question) %>%
    # Shortening the str with str_extract
    .[, eval(question):=str_extract(get(question), paste0("(?<=",eval(question),")([A-Za-z])*"))] %>%
    # Aggregate the counts
    .[,list(N=.N),
            by=c(eval(question), "value")] %>%
    .[, percentage := signif(N/sum(N),3)*100] %>%
  # The output should be plotted and processed, the numbers are already aggregated
    .[order(-N)]
}

# For some survey question that allow multiple choices ( select all that apply), the results are stored in a str list that seperated by ",", this function serve to extract it
MultipleChoiceOptions_func = function(question, dt = multipleChoiceResponses){
  
  # Turning this column into characters
  dt[, (question):= lapply(.SD, as.character ), .SDcols = question ]
  
  # I couldn't get there expresssion to change to with as.character nicely
  # `$`(df , question)<-as.character(`$`(df , question))
  # dt[,get(question)] <- as.character(dt[,get(question)])
  
  # Detecting the appropriate number of split
  t.splits <- max(lengths(strsplit(dt[,get(question)], '\\([^)]+,(*SKIP)(*FAIL)|,\\s*', 
                                   perl = TRUE)))
  
  # t.splits
  t.test <- dt[,.(get(question))] %>%
    .[, paste0("m.", eval(question),
               1:t.splits):=tstrsplit(V1,
                                      '\\([^)]+,(*SKIP)(*FAIL)|,\\s*',
                                      perl = TRUE)] %>%
    .[, colnames(.) %like% "m.*", with=FALSE] %>%
    melt(.,  measure.vars = patterns("^m.*"), na.rm = T) %>% #note that na is removed
  # This output two column by default, with value column correspodings to the individual strings. Should be processed use with aggregation.
        # Aggregate the counts
    .[,.N, by=c("value")] %>%
  # The output should be plotted and processed, the numbers are already aggregated
    .[order(-N)]
}

# This serve to construct a 1:2 tokenise document feature matrix (dfm) while removing stopwords etc, it will output a  wordfrequency df.
Wordclourd_func = function(input, dt = freeformResponses){
  
  # Creating a document-feature matrix
  dfm.txt <- dfm(eval(dt)[!is.na(get(input)), get(input)],
                remove=stopwords("english"),
                remove_symbols = T,
                remove_punct = T,
                remove_numbers = T,
                remove_url = T,
                ngrams=1:2)
  
  ## Rowsum to find individual term's frequency across all documents
  term_frequency<-row_sums(t(dfm.txt)) # This utilised row_sum
  
  ## Create word_freqs
  word_freqs <- data.frame(term = names(term_frequency), num = term_frequency)
  word_freqs
  
  # for starters, word_freqs(basically a df with terms and its frequency) can be processed with wordcloud and barplot
}

```

<br/>
<hr/>
<br/>

# Basic visualisation {.tabset}

This section depicts some basic plots of the survey, which could be used to explore the cross-section data analysis with its tabbed structure. Some of the pre-processing of the variables can be found here as well.

Initially,  I intended to look at into Pay vs Experience and Demographics of countries, but it has since grown up a bit.

<br/>

## Countries

```{r}
# Accounting for long names of Chinas..
multipleChoiceResponses[Country=="People 's Republic of China", Country:= "China"]
multipleChoiceResponses[Country=="Republic of China", Country:= "Taiwan"]

# Dropping it from factors too
multipleChoiceResponses<-droplevels(multipleChoiceResponses)

# plotting
hchart(fct_infreq(multipleChoiceResponses$Country), "column") %>%
  hc_title(text = "Respondent's Country ",
             style = list(color = "Black", useHTML = TRUE)) %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="Country", Asked]),"]",
                           eval(schema[Column=="Country", Question]),
                           "<br>Countries with < 50 counts are aggregated into Other"),
             style = list(color = "Black", useHTML = TRUE)) %>%
  hc_xAxis(text = "Countries", labels = list(rotation = 90))
  
```
**People 's Republic of China - China** and  **Republic of China - Taiwan** is available for selective as separate entries. Both of the names are converted into shorter, one-word form. Also, noted that there are separate entries for selection for Hong Kong.

Given that this is the results of a survey done on Kaggle, there would be some natural bias towards kaggle and English medium. There may exist other data science platforms that are more popular in Other countries, especially if that country's medium of communication is another language(China, Japan, Germany).

Also, the sum of the three entries(Taiwan, China, Hong Kong) would make China the third country with most popular with survey respondents, just after India.

<br/>
<hr/>
<br/>

## Tenure

Tenure can probably be related to Working Experience, although, given that the question of tenure is directed to all, this is a hazy indicator given that some might include their years of coding in their education (which typically isn't included in the years of working experience). There is no better alternative to explore working experience though.

```{r}
hchart(fct_infreq(multipleChoiceResponses$Tenure), "column")%>%
  hc_title(text = "Tenure") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="Tenure", Asked]),"]",
                           eval(schema[Column=="Tenure", Question])
                           ))

# Create a numeric column indicative of current tenure selections
# essentially a host of if, then case to set a numeric value fr m.Tenure
multipleChoiceResponses %>%
  .[Tenure=="3 to 5 years", m.Experience :=4] %>%
  .[Tenure=="6 to 10 years", m.Experience :=8] %>%
  .[Tenure=="1 to 2 years", m.Experience :=2] %>%
  .[Tenure=="More than 10 years", m.Experience :=10]%>% 
  #~hand wavingly, though data science being a relatively young field and that the majority of survey user are in their late 20s or early 30, this figures should be alright
  .[Tenure=="Less than a year", m.Experience :=0] %>%
  .[Tenure=="I don't write code to analyze data", m.Experience :=NA]
# perhaps these people rely on tableau and the likes, in any case, this field would not be indicate of their experience in their profession, removing it

## check
# unique(multipleChoiceResponses[,.(m.Experience, Tenure)])
```


<br/>
<hr/>
<br/>

## Code Writer

```{r}
hchart(fct_infreq(multipleChoiceResponses$CodeWriter), "column")%>%
  hc_title(text = "CodeWriter") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="CodeWriter", Asked]),"]",
                           eval(schema[Column=="CodeWriter", Question])
                           ))
```

Interestingly, about one-third of people don't work with codes. I can only think of three possible reasons, one is that they are moved up into project management roles that don't require them to work with codes. Second, they could be working in more of an analyst role dealing with the likes of tableau/excel or other data analysis software that doesn't require codes. Finally, it is possible that they are working in another field, and are looking to break into data science.

This will be explored with Job title and years of Tenure in a section later.


<br/>
<hr/>
<br/>

## Job Title

```{r}
# hchart(fct_infreq(multipleChoiceResponses$CurrentJobTitleSelect), "column")%>%
#   hc_title(text = "Job Title") %>%
#   hc_subtitle(text = paste("Q","[",eval(schema[Column=="CurrentJobTitleSelect", Asked]),"]",
#                            eval(schema[Column=="CurrentJobTitleSelect", Question])
#                            ))


## Creating a list of Popular job title - Aggregate Job Title
## to be use in later section
AggrJobTitle <- multipleChoiceResponses %>%
  .[!is.na(CurrentJobTitleSelect)&!CurrentJobTitleSelect=="Other",
                        .N, 
    by = CurrentJobTitleSelect] %>%
  .[order(-N)]



# Calculating percentage of respondents for each factor
CurrentJobTitleSelect.Select <- multipleChoiceResponses %>%
  .[!is.na(CurrentJobTitleSelect)] %>%
  .[,  .N,  by = CurrentJobTitleSelect] %>%
  .[, percent:= signif(N/sum(N)*100,3)] %>%
  .[order(-N)]

# Highchart with column and pie chart (percentage)
highchart() %>%
  hc_add_series(CurrentJobTitleSelect.Select, "column", 
                hcaes(x = CurrentJobTitleSelect, y = N), name = "column") %>%
  hc_add_series(CurrentJobTitleSelect.Select, "pie", 
                hcaes(name = CurrentJobTitleSelect, y = percent), name = "Bars") %>%
   # Optiosn for each type of series
  hc_plotOptions(
    series = list(
      showInLegend = FALSE,
      pointFormat = "{point.y}%"
    ),
    column = list(
      colorByPoint = TRUE
      ),
    pie = list(
      colorByPoint = TRUE, center = c('30%', '10%'),
      size = 120, dataLabels = list(enabled = FALSE)
    )) %>%
  # Axis
  hc_xAxis(categories = CurrentJobTitleSelect.Select$CurrentJobTitleSelect) %>%
  #Title & Subtitle
         hc_title(text = "CurrentJobTitleSelect")

```

Evidently, Data Scientist, Software Developer, Data analyst and Scientist/Research are most popular. I  am puzzle by what is the difference between Scientist/Research and Research (Maybe Education might shed a light?), perhaps they should be aggregated into a single option? Though in that case they will be the 3rd most popular job title, even before Data analyst.


<br/>
<hr/>
<br/>

## Past Job title

<br/>

###Select

```{r}
Agg_PastJobTitle <- MultipleChoiceOptions_func("PastJobTitlesSelect")
  
Agg_PastJobTitle %>%
  .[, percentage :=signif(N/sum(N),3)*100,]

# hchart(Agg_PastJobTitle, type="column", hcaes(x = value, y = N, group = value),
#                                    options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
#          hc_title(text = "PastJobTitlesSelect") %>%
#          hc_subtitle(text = paste("Q",
#                                   "[",eval(schema[Column=="PastJobTitlesSelect", Asked]),"]",
#                                   eval(schema[Column=="PastJobTitlesSelect", Question])
#          ))

# Highchart with column and pie chart (percentage)
highchart() %>%
  hc_add_series(Agg_PastJobTitle, "column", 
                hcaes(x = value, y = N), name = "column") %>%
  hc_add_series(Agg_PastJobTitle, "pie", 
                hcaes(name = value, y = percentage), name = "Bars") %>%
   # Optiosn for each type of series
  hc_plotOptions(
    series = list(
      showInLegend = FALSE,
      pointFormat = "{point.y}%"
    ),
    column = list(
      colorByPoint = TRUE
      ),
    pie = list(
      colorByPoint = TRUE, center = c('30%', '10%'),
      size = 120, dataLabels = list(enabled = FALSE)
    )) %>%
  # Axis
  hc_xAxis(categories = Agg_PastJobTitle$value) %>%
  #Title & Subtitle
         hc_title(text = "PastJobTitle") %>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="PastJobTitlesSelect", Asked]),"]",
                                  eval(schema[Column=="PastJobTitlesSelect", Question])
         ))

```

So it seems that most of the Data Science people are coming from Software Developer roles, Researcher, Programmer and Data analyst.

 <br/>
 
### FreeForm

```{r}
## freeformResponse
# colnames(freeformResponses)
# nrow(freeformResponses[!is.na(PastJobTitlesFreeForm)])
# 2094

PastJobTitle_WordFreq<-setDT(Wordclourd_func("PastJobTitlesFreeForm")) %>%
  .[order(-num)] %>%
  .[num>20,] %>%
  .[, percent:=signif(num/sum(num)*100, 3), ]
  

# hchart(t.WTF, type="column", hcaes(x = term, y = num))


highchart() %>%   
  hc_add_series(PastJobTitle_WordFreq, "column", hcaes(x = term, y = num), name = "column") %>%
  hc_add_series(PastJobTitle_WordFreq, "pie", hcaes(name = term, y = percent), name = "Bars")  %>%  # Axis
  hc_xAxis(categories = PastJobTitle_WordFreq$term) %>% #Title & Subtitle
         hc_title(text = "PastJobTitlesFreeForm") %>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="PastJobTitlesFreeForm", Asked]),"]",
                                  eval(schema[Column=="PastJobTitlesFreeForm", Question])
         ))
```


Quite a bit a people wrote manager in freeform response to past job titles. Given the age of the survey respondents, this surprises me a bit. Maybe Job with managers title doesn't require extensive experience in some countries? 


<br/>
<hr/>
<br/>

## Age

```{r}
hchart(multipleChoiceResponses$Age, na.rm =T)%>%
    hc_title(text = "Age") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="Age", Asked]),"]",
                           eval(schema[Column=="Age", Question])
                           ))
```

As noted by other kernels, most the respondents of the survey are young, likely in their mid-20s.

```{r}
# highchart() %>%
#   hc_add_series(density(multipleChoiceResponses[!is.na(Age),Age])) %>%
#   hc_xAxis(plotLines = list(
#     list(
#       value = median(multipleChoiceResponses[!is.na(Age),Age]),
#       color = '#ff0000',
#       width = 3,
#       zIndex = 4,
#       label = list(text = paste("Median:", median(multipleChoiceResponses[!is.na(Age),Age])),
#                    style = list( color = '#ff0000', fontWeight = 'bold' )
#       )),
#     list(
#       value = quantile(multipleChoiceResponses[!is.na(Age),Age], 0.75)[[1]],
#       color = '#ff0000',
#       width = 3,
#       zIndex = 4,
#       label = list(text = paste("Q3:", quantile(multipleChoiceResponses[!is.na(Age),Age], 0.75)[[1]]),
#                    style = list( color = '#ff0000', fontWeight = 'bold' )
#       )),
#     list(
#       value = quantile(multipleChoiceResponses[!is.na(Age),Age], 0.25)[[1]],
#       color = '#ff0000',
#       width = 3,
#       zIndex = 4,
#       label = list(text = paste("Q1:", quantile(multipleChoiceResponses[!is.na(Age),Age], 0.25)[[1]]),
#                    style = list( color = '#ff0000', fontWeight = 'bold' )
#       ))))
```

<br/>
<hr/>
<br/>

## Career Switcher

```{r}
hchart(fct_infreq(multipleChoiceResponses$CareerSwitcher), na.rm =T,
       options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
    hc_title(text = "CareerSwitcher") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="CareerSwitcher", Asked]),"]",
                           eval(schema[Column=="CareerSwitcher", Question])
                           ))
```

Plenty of Workers1 (note that there probably implies non-coding worker as per the schema, seeing that there is a separate category for CodingWorker) are intending to turn into data science. 

Would be interesting to see how this group fares (for noncoders).

<br/>
<hr/>
<br/>

## Salary Change

```{r}
# hchart(fct_infreq(multipleChoiceResponses$SalaryChange), na.rm =T,
#        options3d = list(enabled = TRUE, beta = 1, alpha = 1)) %>%
#     hc_title(text = "SalaryChange") %>%
#   hc_subtitle(text = paste("Q","[",eval(schema[Column=="SalaryChange", Asked]),"]",
#                            eval(schema[Column=="SalaryChange", Question])
#                            ))


# Extracting all column that cosist of JobFactor string.
SalaryChange.Select <- MultipleChoice_func("SalaryChange")

highchart() %>%   
  hc_add_series(SalaryChange.Select, "column", hcaes(x = value, y = N), name = "column") %>%
  hc_add_series(SalaryChange.Select, "pie", hcaes(name = value, y = percentage), name = "Bars") %>% 
   # Optiosn for each type of series
  hc_plotOptions(
    series = list(
      showInLegend = FALSE,
      pointFormat = "{point.y}%"
    ),
    column = list(
      colorByPoint = TRUE
    ),
    pie = list(
      colorByPoint = TRUE, center = c('20%', '10%'),
      size = 120, dataLabels = list(enabled = FALSE)
    )) %>%
  # Axis
  hc_xAxis(categories = SalaryChange.Select$value) %>%
  #Title & Subtitle
         hc_title(text = "SalaryChange") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="SalaryChange", Asked]),"]",
                           eval(schema[Column=="SalaryChange", Question])
                           ))

```

Almost a third of the people saw a 20% increase in salary over 3 years.

<br/>
<hr/>
<br/>

## Remote Work

```{r}
hchart(multipleChoiceResponses$RemoteWork, na.rm =T)%>%
    hc_title(text = "RemoteWork") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="RemoteWork", Asked]),"]",
                           eval(schema[Column=="RemoteWork", Question])
                           ))
```

<br/>
<hr/>
<br/>

## Currency

The only meaningful column in the ConversionRates provided along with survey results are 

* OriginCountry : (USD, EUR, AUD) which is more indicative of currency, the column name is somewhat misleading. 

* conversionRates : Respective conversion rates of various currencies to USD. 

```{r}
# # Cleaning up Conversion Rates, removing X which seems to be a raw ID
conversionRates$X=NULL

# # Renaming conversionRates to facillate easier join
colnames(conversionRates) <- c("Code", "ExchangeRate")
```

The conversion rates dt will need to be joined with the country-currencies input, which can be used to identify the original currencies of the respective countries, allowing us to identify the number of individual earning foreign currencies in different countries.

```{r}
# # joining currency2CountryName and conversionRates together
Currency2CountryConversion <- currency2CountryName[conversionRates, on=.(Code)]

# # Converting country code into character
# # Currency2CountryConversion$CountryCode <- as.character(Currency2CountryConversion$CountryCode)
multipleChoiceResponses$CompensationAmount <- as.numeric(as.character(multipleChoiceResponses$CompensationAmount))

# # It seems Currency2CountryConversion has some NA/nonunique value for Country Name and Code
# glimpse(unique(Currency2CountryConversion[is.na(Country)]))
# $ Country      <fctr> NA, NA, NA, NA
# $ CountryCode  <fctr> NA, NA, NA, NA
# $ Currency     <fctr> NA, NA, NA, NA
# $ Code         <fctr> RSD, BAM, BYN, GHS
# $ ExchangeRate <dbl> 0.010020, 0.611383, 0.518071, 0.225710
# # Removing them as this will cause duplicates when merging
Currency2CountryConversion <- Currency2CountryConversion[!is.na(Country)]

# # Combining the main dt with Currency2Country
multipleChoiceResponses <- Currency2CountryConversion[] %>%
  .[multipleChoiceResponses, on=.(Country)] %>%
  # # Create a column that account for the conversion rate of local currencies
  .[!is.na(CompensationAmount), m.CompensationLocal:= CompensationAmount * ExchangeRate]

# # Changing columns into as.character to facillitate comparison for later section
multipleChoiceResponses[, c("Code", "CompensationCurrency"):=lapply(.SD, as.character), .SDcols=c("Code", "CompensationCurrency")]




# Comparison
# unique(multipleChoiceResponses[CompensationCurrency==Code,.(CompensationCurrency, Code)])
```

<br/>
<hr/>
<br/>

### Currency Codes & Map

```{r}
data(worldgeojson, package = "highcharter")

# # Plotting for highcharter map
# hcmap(mapData = worldgeojson,
#       download_map_data=FALSE,
#       data = Currency2CountryConversion, value = "ExchangeRate",
#       joinBy = c("iso-a2", "CountryCode"), name = "Demography")

## while with download_map_data=FALSE, it doesn't require one to load external geojson data (doesn't work for kaggle) , I ran into html parse error when kniting.

Currency2CountryConversion$"iso-a2" <- Currency2CountryConversion$CountryCode
Currency2CountryConversion$iso2 <- Currency2CountryConversion$CountryCode
Currency2CountryConversion$value <- Currency2CountryConversion$ExchangeRate
 
highchart()%>%
  hc_add_series_map(worldgeojson, df = Currency2CountryConversion, value = "value", joinBy = "iso2",
                    dataLabels = list(enabled = TRUE,
                                      format = '{point.name}'))
```

<br/>
<hr/>
<br/>

## Learning Platform Select

```{r}
Agg_LearningPlatformSelect <- MultipleChoiceOptions_func("LearningPlatformSelect") 


hchart(Agg_LearningPlatformSelect, type="column", hcaes(x = value, y = N, group = value),
                                   options3d = list(enabled = TRUE, beta = 1, alpha = 1)) %>%
  # title and subtitle
         hc_title(text = "LearningPlatformSelect") %>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="LearningPlatformSelect", Asked]),"]",
                                  eval(schema[Column=="LearningPlatformSelect", Question])
                                  ))


```

Obviously, as this is a survey done on Kaggle, there would be a huge bias towards Kaggle. Other popular medium of learning are Online Courses, Personal Projects, Blogs and Youtube Videos.

<br/>
<hr/>
<br/>


## Proving your worth

### Proven Knowledge Select

```{r}
Select_ProveKnowledge <- MultipleChoice_func("ProveKnowledge") 
## Basic plot
# hchart(Select_ProveKnowledge, type="column", hcaes(x = value, y = N, group = value)) %>%
#   # title and subtitle
#   hc_title(text = "ProveKnowledge") %>%
#   hc_subtitle(text = paste("Q","[",eval(schema[Column=="ProveKnowledgeSelect", Asked]),"]",
#                            eval(schema[Column=="ProveKnowledgeSelect", Question])
#   ))

# highchart
highchart() %>%   
  hc_add_series(Select_ProveKnowledge, "column", hcaes(x = value, y = N), name = "column") %>%
  hc_add_series(Select_ProveKnowledge, "pie", hcaes(name = value, y = percentage), name = "Pie") %>% 
  # Optiosn for each type of series
  hc_plotOptions(
    series = list(
      showInLegend = FALSE,
      pointFormat = "{point.y}%"
    ),
    column = list(
      colorByPoint = TRUE
    ),
    pie = list(
      colorByPoint = TRUE, center = c('30%', '10%'),
      size = 120, dataLabels = list(enabled = FALSE)
    )) %>%
  # Axis
  hc_xAxis(categories = Select_ProveKnowledge$value) %>%
  # Title & Subtitle
  hc_title(text = "ProveKnowledge") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="ProveKnowledgeSelect", Asked]),"]",
                           eval(schema[Column=="ProveKnowledgeSelect", Question])
  ))
```

Evidently, the majority learners think that working experience is the most important methods to prove their knowledge of DS/ML. This is followed by Kaggle competitions, Online courses, and Github Portfolio. 

<br/>

### Proven Knowledge FreeForm

```{r}
# ProveKnowledgeFreeForm
ProveKnowledge_FreeForm <- Wordclourd_func("ProveKnowledgeFreeForm")
wordcloud(ProveKnowledge_FreeForm$term, ProveKnowledge_FreeForm$num, max.words = 100,
           random.order=FALSE, colors=brewer.pal(8,"Dark2"), rot.per=.3, scale=c(3,.5))
```

Its equivalent freeform form of data, however, are overwhelming pointing towards projects. Although limited people proceed to fill the free-form data.

I think this previous selection for proven knowledge has limited the respondents to choose only amount the listed choices (ie, bias in the sense that most people are unlikely to select "Other" option and fill in projects, instead prefer to choose amount the available options). Among the choice I think that are missing from the list are projects, open-sourced packages contributions, blogs, and publication.


<br/>
<hr/>
<br/>

## Algorithm Understanding

```{r}
# hchart(multipleChoiceResponses$AlgorithmUnderstandingLevel, na.rm =T)%>%
#     hc_title(text = "AlgorithmUnderstandingLevel") %>%
#   hc_subtitle(text = paste("Q","[",eval(schema[Column=="AlgorithmUnderstandingLevel", Asked]),"]",
#                            eval(schema[Column=="AlgorithmUnderstandingLevel", Question])
#                            ))
# head(multipleChoiceResponses$AlgorithmUnderstandingLevel)

# Calculating percentage of respondents for each factor
AlgorithmUnderstanding.Select <- multipleChoiceResponses %>%
  .[!is.na(AlgorithmUnderstandingLevel)] %>%
  .[,  .N,  by = AlgorithmUnderstandingLevel] %>%
  .[, percent:= signif(N/sum(N)*100,2)] %>%
  .[order(-N)]

# Highchart with column and pie chart (percentage)
highchart() %>%
  hc_add_series(AlgorithmUnderstanding.Select, "column", 
                hcaes(x = AlgorithmUnderstandingLevel, y = N), name = "column") %>%
  hc_add_series(AlgorithmUnderstanding.Select, "pie", 
                hcaes(name = AlgorithmUnderstandingLevel, y = percent), name = "Bars") %>%
   # Optiosn for each type of series
  hc_plotOptions(
    series = list(
      showInLegend = FALSE,
      pointFormat = "{point.y}%"
    ),
    column = list(
      colorByPoint = TRUE
      ),
    pie = list(
      colorByPoint = TRUE, center = c('30%', '10%'),
      size = 120, dataLabels = list(enabled = FALSE)
    )) %>%
  # Axis
  hc_xAxis(categories = AlgorithmUnderstanding.Select$AlgorithmUnderstandingLevel) %>%
  #Title & Subtitle
         hc_title(text = "AlgorithmUnderstandingLevel")


```


<br/>
<hr/>
<br/>

## Impactful Algorithm FreeForm

Question
```{r}
schema[Column=="ImpactfulAlgorithmFreeForm", Question]
```

Wordcloud plots 

```{r}


# ImpactfulAlgorithmFreeForm
ImpactfulAlgorithm_FreeForm <-  Wordclourd_func("ImpactfulAlgorithmFreeForm")
wordcloud(ImpactfulAlgorithm_FreeForm$term, ImpactfulAlgorithm_FreeForm$num, max.words = 100,
           random.order=FALSE, colors=brewer.pal(8,"Dark2"), rot.per=.3, scale=c(3,.5))

```

Well, regression is still the most impactful algorithm, I guess it pays to be simple and easily interpretable. All other popular algorithms such as random forest, neural network, logistic regression are also mentioned.

<br/>
<hr/>
<br/>

# Mixed Visualisation

Most of the kernels that I had seen looks to explore the survey results with bar charts. While it easily shows which are the most popular factor, the bar chart may appear misleading if there are fewer people submitting responses for a particular section, or that the respondents are divided, dividing into two extremes. Some respondents may just not be familiar with a particular option.

I attributed each available factor to a linear scale (not that it has to be linear), such a that for a 3-factor list, it would be considered as 0, 1, 2 instead,  higher number implying a more favorable condition ( the higher the better). 

Also, since the list of questions are identical for a particular extraction of datasets ( ie Job Factor, I will just adopt a random one of the exact question from the scheme to depict the question clearly).

<br/>
<hr/>
<br/>

## Job Factor

```{r}
# Extracting all column that cosist of JobFactor string.
JobFactor.Select <- MultipleChoice_func("JobFactor")%>%
  .[order(JobFactor)]

## Calculating percentage of respondents for each factor, though this segments of codes is disable as the precentage doesn't seem meaningful
# JobFactor.MSelect <- JobFactor.Select %>%
  # .[, .(percent=sum(percentage)), by = JobFactor]

# hchart(t.WTF, type="column", hcaes(x = JobFactor, y = N, group = value),
                                   # options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
         # hc_title(text = "JobFactor") 


## Highchart with column and pie chart (percentage)
# highchart() %>%   
#   hc_add_series(JobFactor.Select, "column", hcaes(x = JobFactor, y = N, group = value), name = "column") %>%
#   hc_add_series(JobFactor.MSelect, "pie", hcaes(name = JobFactor, y = percent), name = "Bars") %>% 
#    # Optiosn for each type of series
#   hc_plotOptions(
#     series = list(
#       showInLegend = FALSE,
#       pointFormat = "{point.y}%"
#     ),
#     pie = list(
#       colorByPoint = TRUE, center = c('30%', '10%'),
#       size = 120, dataLabels = list(enabled = FALSE)
#     )) %>%
#   # Axis
#   hc_xAxis(categories = JobFactor.Select$JobFactor) %>%
#   #Title & Subtitle
#          hc_title(text = "JobFactor")

# Values for spline plot
Avg_JobFactor <- JobFactor.Select %>%
  .[value == "Very Important", score := 2] %>%
  .[value == "Somewhat important", score := 1] %>%
  .[value == "Not important", score := 0] %>%
  .[,list(Average = signif(mean(score*N)/mean(N),3)),by=list(JobFactor)]%>%
  .[order(JobFactor)]

# Double y axis highchart
highchart() %>%
  hc_yAxis_multiples(
    list(lineWidth = 3, title = list(text="N")),
    list(showLastLabel = FALSE, opposite = T, title = list(text="Score Out of 2"))
  ) %>%
  hc_add_series(JobFactor.Select, "column", 
                hcaes(x = JobFactor, y = N, group = value)) %>%
  hc_add_series(Avg_JobFactor, "spline", hcaes(x = JobFactor, y = Average), 
                name = "AvgScore",  yAxis = 1) %>%
  hc_xAxis(categories = Avg_JobFactor$JobFactor)%>%
  # title and subtitle
         hc_title(text = "JobFactor.Select")%>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="JobFactorTitle",
                                                  Asked]),"]",
                                  eval(schema[Column=="JobFactorTitle",
                                              Question])
                                  )) 

```

Interestingly, while the bar chart shows that company/funding is also rather important, there exist certain segments of individuals who think it is not as important (thereby lowering the score). 

Overall, I think the spine plot better depicts Learners' preference for opportunities in Learning, Office, Salary, Languages, and Management. Value concepts and abstracts notions such as diversity and leader reputation are second to their consideration. This seems better comfort to the norm.

<br/>
<hr/>
<br/>

## Learning Platform Usefulness

```{r}
# Extracting values for column plot
Agg_LearningPlatform <- MultipleChoice_func("LearningPlatformUsefulness") %>%
  .[order(LearningPlatformUsefulness)]

# Values for spline plot
Avg_LearningPlatform <- Agg_LearningPlatform %>%
  .[value == "Very useful", score := 2] %>%
  .[value == "Somewhat useful", score := 1] %>%
  .[value == "Not Useful", score := 0] %>%
  .[,list(Average = signif(mean(score*N)/mean(N),3)),by=list(LearningPlatformUsefulness)]%>%
  .[order(LearningPlatformUsefulness)]


# hchart(Agg_LearningPlatform, type="column", hcaes(x = LearningPlatformUsefulness, y = N, group = value), options3d = list(enabled = TRUE, beta = 1, alpha = 1)) %>%
#   # title and subtitle
#          hc_title(text = "LearningPlatformUsefulness") 

# Double y axis highchart
highchart() %>%
  hc_yAxis_multiples(
    list(lineWidth = 3, title = list(text="N")),
    list(showLastLabel = FALSE, opposite = T, title = list(text="Score Out of 2"))
  ) %>%
  hc_add_series(Agg_LearningPlatform, "column", hcaes(x = LearningPlatformUsefulness
                                                      , y = N, group = value)) %>%
  hc_add_series(Avg_LearningPlatform, "spline", hcaes(x = LearningPlatformUsefulness, y = Average), name = "AvgScore",  yAxis = 1) %>%
  hc_xAxis(categories = Avg_LearningPlatform$LearningPlatformUsefulness)%>%
  # title and subtitle
         hc_title(text = "LearningPlatformUsefulness")%>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="LearningPlatformUsefulnessArxiv",
                                                  Asked]),"]",
                                  eval(schema[Column=="LearningPlatformUsefulnessArxiv",
                                              Question])
                                  )) 
# Since the schema's question is the same for all of the learning platform usefulness, I will just use the one from Arxiv
```

* Projects are the most useful, followed by Course. Then, we have Kaggle that is tied with SO at 1.61 score.
* Tutoring is ranked quite high, despite its small population

<br/>
<hr/>
<br/>

## Work Tools Frequency

```{r}
# Extracting values for column plot
Agg_WorkToolsFre  <- MultipleChoice_func("WorkToolsFrequency") %>%
  .[order(WorkToolsFrequency)]
# hchart(t.WTF, type="column", hcaes(x = WorkToolsFrequency, y = N, group = value))

# Values for spline plot
Avg_WorkToolsFre <- Agg_WorkToolsFre %>%
  .[value == "Often", score := 3] %>%
  .[value == "Most of the time", score := 2] %>%
  .[value == "Sometimes", score := 1] %>%
  .[value == "Rarely", score := 0] %>%
  .[,list(Average = signif(mean(score*N)/mean(N),3)),by=list(WorkToolsFrequency)]%>%
  .[order(WorkToolsFrequency)]

# Double y axis highchart
highchart() %>%
  hc_yAxis_multiples(
    list(lineWidth = 3, title = list(text="N")),
    list(showLastLabel = FALSE, opposite = T, title = list(text="Score Out of 3"))
  ) %>%
  hc_add_series(Agg_WorkToolsFre, "column", hcaes(x = WorkToolsFrequency
                                                      , y = N, group = value)) %>%
  hc_add_series(Avg_WorkToolsFre, "spline", hcaes(x = WorkToolsFrequency, y = Average), name = "AvgScore",  yAxis = 1) %>%
  hc_xAxis(categories = Avg_WorkToolsFre$WorkToolsFrequency, labels = list(rotation=90))%>%
  # title and subtitle
         hc_title(text = "WorkToolsFrequency")%>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="WorkToolsFrequencyAWS",
                                                  Asked]),"]",
                                  eval(schema[Column=="WorkToolsFrequencyAWS",
                                              Question])
                                  )) 
```



Although Python and R proved to be most popular options depicted in the bar chart, the rank with the AvgScore would better illustrate the usefulness of a particular worktool.

By the ranks

1. Unix

2. SQL

3. Python

4. Select

5. Jupyter

6. R

"Select" despite it's low popularity, score quite well.

<br/>
<hr/>
<br/>

## Job Skill Importance

```{r}
# Extracting values for column plot
Agg_JobSkillImportance <- MultipleChoice_func("JobSkillImportance") %>%
  .[order(JobSkillImportance)]

# Values for spline plot
Avg_JobSkillImportance <- Agg_JobSkillImportance %>%
  .[value == "Necessary", score := 2] %>%
  .[value == "Nice to have", score := 1] %>%
  .[value == "Unnecessary", score := 0] %>%
  .[,list(Average = signif(mean(score*N)/mean(N),3)),by=list(JobSkillImportance)]%>%
  .[order(JobSkillImportance)]

# Double y axis highchart
highchart() %>%
  hc_yAxis_multiples(
    list(lineWidth = 3, title = list(text="N")),
    list(showLastLabel = FALSE, opposite = T, title = list(text="Score Out of 2"))
  ) %>%
  hc_add_series(Agg_JobSkillImportance, "column", hcaes(x = JobSkillImportance
                                                      , y = N, group = value)) %>%
  hc_add_series(Avg_JobSkillImportance, "spline", hcaes(x = JobSkillImportance, y = Average), name = "AvgScore",  yAxis = 1) %>%
  hc_xAxis(categories = Avg_JobSkillImportance$JobSkillImportance)%>%
  # title and subtitle
         hc_title(text = "JobSkillImportance")%>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="JobSkillImportanceR",
                                                  Asked]),"]",
                                  eval(schema[Column=="JobSkillImportanceR",
                                              Question])
                                  )) 
# The schema's question is the same for all of the skill important

```


Importance by the ranks of Average Score.

1. Python

2. Stats

3. Visualisations

4. SQL

5. R

So I guess programming language (Python/R), Statistics, Data visualisation are the core skills.

<br/>
<hr/>
<br/>


## Work Methods Frequency

```{r}
# Extracting values for column plot
Agg_WorkMethodsFrequency <- MultipleChoice_func("WorkMethodsFrequency") %>%
  .[order(WorkMethodsFrequency)]

# Values for spline plot
Avg_WorkMethodsFrequency  <- Agg_WorkMethodsFrequency %>%
  .[value == "Often", score := 3] %>%
  .[value == "Most of the time", score := 2] %>%
  .[value == "Sometimes", score := 1] %>%
  .[value == "Rarely", score := 0] %>%
  .[,list(Average = signif(mean(score*N)/mean(N),3)),by=list(WorkMethodsFrequency )]%>%
  .[order(WorkMethodsFrequency)]


# Double y axis highchart
highchart() %>%
  hc_yAxis_multiples(
    list(lineWidth = 3, title = list(text="N")),
    list(showLastLabel = FALSE, opposite = T, title = list(text="Score Out of 3"))
  ) %>%
  hc_add_series(Agg_WorkMethodsFrequency, "column", hcaes(x = WorkMethodsFrequency, 
                                                          y = N, group = value)) %>%
  hc_add_series(Avg_WorkMethodsFrequency, "spline", hcaes(x = WorkMethodsFrequency, 
                                                          y = Average), name = "AvgScore",  yAxis = 1) %>%
  hc_xAxis(categories = Avg_WorkMethodsFrequency$WorkMethodsFrequency)%>%
  # title and subtitle
         hc_title(text = "WorkMethodsFrequency")%>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="WorkMethodsFrequencyA/B",
                                                  Asked]),"]",
                                  eval(schema[Column=="WorkMethodsFrequencyA/B",
                                              Question])
                                  )) 

```

By the ranks of Average Score.

1. Data Visualisation

2. Cross

3. GBM - tied 

4. LogisticRegression  - tied 

Not sure what to make of "Select" low average score, perhaps it is just not popular with worker?


<br/>
<hr/>
<br/>

# Interesting combination

## Network Graph of Career Change
If we draw a network graph assuming therea connection between past job(s) and current job.

```{r}
# Making sure that this column is in characters
JobNetworkPlot_dt <- multipleChoiceResponses[, PastJobTitlesSelect:=lapply(.SD, as.character ), .SDcols = c("PastJobTitlesSelect") ] %>%
  # Selecting only relevent columns of "CurrentJobTitleSelect" and "PastJobTitlesSelect"
  .[,colnames(.) %in% c("PastJobTitlesSelect", "CurrentJobTitleSelect"), with = FALSE] 

# Determinating the appropriate number of splits
t.splits <- max(lengths(strsplit(JobNetworkPlot_dt$PastJobTitlesSelect, '\\([^)]+,(*SKIP)(*FAIL)|,\\s*', perl = TRUE)))

t.links <- JobNetworkPlot_dt %>%
  # There are respondents that gave a list of previous job titles, yet did not have their current job title recorded, the past job titles select would still hold valueble data. For these people,chanaging their Current JobTitle to "Not Given" 
  .[is.na(CurrentJobTitleSelect), CurrentJobTitleSelect:="Not given"] %>%
  # strsplit the past job title select base on ","
  .[, paste0("m.PastJobTitlesSelect",
             1:t.splits):=tstrsplit(PastJobTitlesSelect,
                                    '\\([^)]+,(*SKIP)(*FAIL)|,\\s*',
                                    perl = TRUE)] %>%
  melt(.,  measure.vars = patterns("^m.*"), na.rm = T) %>%
  # Removing those who arent/ havent start working
  .[!value=="I haven't started working yet"] %>%
  .[,(colnames(.) %in% c("CurrentJobTitleSelect", "value")),with = F] %>%
  .[,list(weight=.N), by = c("CurrentJobTitleSelect", "value")]

t.vertices <- JobNetworkPlot_dt %>%
  # Similar to previous t.link tstrsplit at this point
  .[is.na(CurrentJobTitleSelect), CurrentJobTitleSelect:="Not given"] %>%
  # strsplit the past job title select base on ","
  .[, paste0("m.PastJobTitlesSelect",
             1:t.splits):=tstrsplit(PastJobTitlesSelect,
                                    '\\([^)]+,(*SKIP)(*FAIL)|,\\s*',
                                    perl = TRUE)] %>%
  .[, names(.)!="PastJobTitlesSelect", with =F]%>%
  # splitting all columns into value
  melt(.,  measure.vars = patterns("*"), na.rm = T) %>%
  # Removing those who arent/ havent start working
  .[!value=="I haven't started working yet"] %>%
  .[,list(Frequency=.N), by = value]%>%
  .[,Previous_percent:=signif(Frequency/sum(Frequency)*100,3)]

t.vertices_w_current <- multipleChoiceResponses %>%
  .[is.na(CurrentJobTitleSelect), CurrentJobTitleSelect:="Not given"] %>%
  .[!is.na(CurrentJobTitleSelect),.N, by = CurrentJobTitleSelect ] %>%
  setnames(.,  c("value", "N")) %>%
  .[, value := as.character(value)] %>%
  .[t.vertices, on ="value" ] %>%
  .[,Current_percent:=signif(N/sum(N, na.rm = T)*100,3)]

## Making network list with igraph
net <- graph_from_data_frame(d=t.links, vertices =t.vertices_w_current, directed=T) 
net <- simplify(net, remove.multiple = F, remove.loops = T) 
# plot(net, edge.arrow.size=.4,vertex.label=V(net)$name, vertex.size = 10, edge.width=E(net)$weight/200)
# plot(net, edge.arrow.size=.4,layout=layout_in_circle, edge.width=E(net)$weight/200)

## Auesthetic and details  for hchart/plotting on network
wc <- cluster_walktrap(net)
V(net)$comm <- membership(wc)
V(net)$color <- colorize(membership(wc))
# V(net)$betweenness <- betweenness(net)
# V(net)$color <- colorize(V(net)$betweenness)
# V(net)$degree <- degree(net)
V(net)$size <- V(net)$Frequency^2
V(net)$label <- V(net)$name
E(net)$width <- E(net)$weight/150
# E(net)$arrow.size <- 15  # doesnt' seems to have an effect

hchart(net, layout = layout_with_fr)
```

The color is indicative of the communities in the network graph, acquired via **cluster_walktrap**. Sadly, while highchart's plot is interactive, I couldn't get the arrow to be shown in the network graph ( as shown where have the individuals been moving).

The Weight options for the width of the lines are manually set to reduce the visibility of less job title changes. An alternative approach is to implement a cutoff/threshold value as to when to draw a line connecting the nodes ( sparsity ).

The size of the individual nodes is indicative of the population of respective current job title.

Overall, it seems Data Scientist is the core of the network plots, with most of its network coming from data analyst, Software Developer/Software Engineer, and Researcher.


<br/>
<hr/>
<br/>


# Differences of Percentage in of The Jobtitle of current and past.

If we plot the percentage difference between job title of current and past ( though not all positions are equal, some roles may appear more frequency simply due to it being a highly competitive filed).

```{r}
t.vertices_dif <- t.vertices_w_current[value!="Not given"] %>%
  .[,Diff_percent := Current_percent - Previous_percent] %>%
  .[order(-Diff_percent)] %>%
  .[, color := colorize(Diff_percent)]

highchart()%>%
  hc_add_series(t.vertices_dif, "bar", hcaes(x = value, y = Diff_percent, color = color)) %>%
  hc_xAxis(categories = t.vertices_dif$value) %>%
  hc_title(text = "Differences of Percentage in of The Jobtitle of current and past")
```

This shows that the job titles of Data scientist and Scientist/Researcher have been becoming popular over time, ie, while the percentage of those who once held a title of programmer and data analyst has decreased. I wonder if this means that Kaggle survey respondents have been slowly moving into their field of choice (Data Science) after parting from their past jobs.  


<br/>
<hr/>
<br/>


## Non Coders & Job Title

```{r}
Agg_CoderJob<-multipleChoiceResponses[!is.na(CurrentJobTitleSelect) & !is.na(CodeWriter)] %>%
  .[, .N, by=.(CurrentJobTitleSelect, CodeWriter)] %>%
  .[order(-N)]

hchart(Agg_CoderJob, type="column", hcaes(x = CurrentJobTitleSelect, y = N, group = CodeWriter)) %>%
hc_title(text = "Coders with relation to Job Title") 

```

Well, it seems close to half of the Software Engineer don't write codes? That's a bit strange.

In the case of Business Analyst and Data Analyst, a number of noncoders could maybe be attributed to their dealing with other statistical software. Perhaps some of the jobs still involve around good old excel.



<br/>
<hr/>
<br/>

### Non Coders and their career


```{r}
# Typically, we are restricted to 3 dimensional plots, x, y, group. 
# though, there are also the paste-combine trick
NonCodersTitle<-c("Software Developer/Software Engineer", "Business Analyst", "Programmer")

t.WTF <- multipleChoiceResponses %>%
  .[!is.na(CurrentJobTitleSelect) & !is.na(m.Experience)] %>%
  # Selecting only NoncodersTitle
  .[CurrentJobTitleSelect %in% NonCodersTitle ] %>%
  .[, Combined:=paste(CurrentJobTitleSelect,"-", m.Experience)] %>%
  .[, .N, by=.(Combined, CodeWriter, m.Experience)] %>%
  .[order(m.Experience, Combined, CodeWriter)] 

hchart(t.WTF, type="bar", hcaes(x = Combined, y = N, group = CodeWriter)) %>%
  # hc_xAxis(labels = list(rotation=90)) %>%
  hc_title(text = "Jobs with significant coders differentiate by Experience") %>%
  hc_subtitle(text="Coders (Yes/No) ; the length of Tenure is indicated by the median number after the job title.")

```

In both three case, it seems that some Business Analyst, Programmers, and Software engineer entry level jobs do not require the entrant to be coders. There exist a significant amount of noncoders in these jobs. However, it seems that those with more working experience in these fields do write codes.

It seems that these professions are a good staging ground for those who are intending venture into Data Science for those who are weak on the codes/programming side. Especially if you are from another field. Although, from what I seen (in Asia) , those Business Analyst roles typically require finance/business background instead of science.

On the other hand, the fabled "manager role" that dont require coding is elusive where experienced coders migrate to is nowhere to be found.


<br/>
<hr/>
<br/>

## Country vs Compensation Currency, Compensation Amount

```{r}
# Turning CompensationAmountfrom factor into numeric column
multipleChoiceResponses$CompensationAmount <- as.numeric(as.character(multipleChoiceResponses$CompensationAmount))

# Create duplicate columns of original to allow manipulation
multipleChoiceResponses$m.CompensationAmount <- multipleChoiceResponses$CompensationAmount
multipleChoiceResponses$m.CompensationCurrency <- multipleChoiceResponses$CompensationCurrency

# From the quantile value (Q1 - Q3) in this case, I think one can safetly assume that the salary of those living in US can be changed to USD.
multipleChoiceResponses[Country=="United States" & 
                          !is.na(CompensationAmount),
                        list(.N, 
                             Median=median(CompensationAmount),
                             Q1=quantile(CompensationAmount, 0.25),
                             Q3=quantile(CompensationAmount, 0.75)
                        ), by=CompensationCurrency] %>%
  .[N>5]
```

From the quantile value (Q1 - Q3) in this case, I think one can safely assume that the salary of those living in the states can be changed to USD.

```{r}
# Change the Compensation Currency of those living in US yet did not select a currency into USD.
multipleChoiceResponses[!is.na(CompensationAmount) & 
                          is.na(CompensationCurrency) &
                          Country=="United States", 
                        m.CompensationCurrency:="USD"]

# Converting all curruncies to USD to ease comparison between different currencies
multipleChoiceResponses<-multipleChoiceResponses[!is.na(CompensationAmount) &
                                                   !is.na(ExchangeRate & 
                                                            CompensationCurrency!= Code),
                                                 m.CompensationUSD := m.CompensationAmount*ExchangeRate] %>%
  # Adapting partial ikleiman's treatment of salary, where if the salary is between 6 and 36 times of the median, it is assumed that the respondant entered a monthly salary, hence, * 12
      # https://www.kaggle.com/ikleiman/data-scientists-salaries-around-the-world
  .[CompensationAmount >= median(CompensationAmount)/36 & 
      CompensationAmount < median(CompensationAmount)/6,
    ':='(m.CompensationAmount = CompensationAmount*12,
         m.CompensationUSD = CompensationAmount*ExchangeRate*12), 
    by = Country] 
  

```

I adapted ikleiman's treatment of salary to account to account for correction in guessing when survey respondents have inserted their monthly salary instead of per annum. 


<br/>
<hr/>
<br/>

## Individuals Earnings distribution in USD per Country

```{r}
# This remove the 5% of head and tail of compensation in USD for various countries
Individual_Earning.dt <- multipleChoiceResponses %>%
  .[, names(.) %in% c("m.CompensationUSD","EmploymentStatus", "Country"), with = F] %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationUSD) &
      !m.CompensationUSD==0 &
      EmploymentStatus == "Employed full-time"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  # .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[order(Country)] %>%
  # .[, if(.N > 10) .SD, by=c("Country")] %>%
  .[,':='(q95= quantile(m.CompensationUSD, 0.95),
          med= median(m.CompensationUSD),
          q5 = quantile(m.CompensationUSD, 0.05)), by = Country]%>%
  .[m.CompensationUSD<q95, ] %>%
  .[m.CompensationUSD>q5, ]  %>%
  .[order(-med)]

# # highchart
# hcboxplot(x = Individual_Earning.dt$m.CompensationUSD, var = Individual_Earning.dt$Country) %>%
#   hc_xAxis(labels = list(rotation=0)) %>%
#   hc_yAxis(title = list(text="USD")) %>%
#   hc_title(text = "Boxplot of m.CompensationUSD per country") 

## gglot 
fill <- "#4271AE"
lines <- "#1F3552"

ggplot(Individual_Earning.dt, aes(x = reorder(Country, m.CompensationUSD, median), 
                                  y = m.CompensationUSD)) +
        geom_boxplot(colour = lines, fill = fill,
                     size = 1) +
        scale_y_continuous(name = "Compensation in USD") +
        scale_x_discrete(name = "Country") +
        ggtitle("Boxplot of CompensationUSD by Country") +
        theme_bw() +
        theme(panel.grid.major = element_line(colour = "#d3d3d3"),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, face = "bold"),
              axis.title = element_text(face="bold"),
              axis.text.x = element_text(colour="black", size = 9, angle = 90,
                                         hjust = 1,  vjust = 0.5),
              axis.text.y = element_text(colour="black", size = 9),
              axis.line = element_line(size=0.5, colour = "black"))
```

I used ggplot's boxplot here as I couldn't get the highchart's boxplot (hcboxplot)'s to have its categories sorted by median value. 

The ranking of countries slightly differs from that of [ikeiman](https://www.kaggle.com/ikleiman/data-scientists-salaries-around-the-world), probably because of slightly differing processes. While I adapted ikeiman's treatment to account for monthly salary ( ie compensation \times 12 if the value is between 6 and 36 fractions of the median salary.), I also went for a more narrow filter (accepting only those listed in respective local currencies of their home country) and simply applied and 5% cut on head and tail of the distribution.

Hence, the compensations listed here is probably more appropriate to those employed and compensated locally instead of remotely, as we will see in next section, country like Isreal, Ukraine, India bosted a significant number of individual earning foreign currencies


<br/>
<hr/>
<br/>


### Number of Individuals earning Foreign Currencies

```{r}
# There exist individuals who are taking foreign currency, perhaps they are doing remote work or working overseas? 
Foreign.dt<-multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & !is.na(m.CompensationCurrency)] %>%
  # Filtering cases where the CompensationCurrency isn't identical with the Country Currency
  .[CompensationCurrency!= Code] %>%
  .[, .N, by = list(Country)] %>%
  .[order(-N)] %>%
  .[, percent:=signif(N/sum(N)*100, 3), ]


highchart() %>%   
  hc_add_series(Foreign.dt, "column", hcaes(x = Country, y = N), name = "column", colorByPoint = TRUE) %>%
  hc_add_series(Foreign.dt, "pie", hcaes(name = Country, y = percent), name = "Bars")  %>%  # Axis
  hc_xAxis(categories = Foreign.dt$Country) %>% #Title & Subtitle
         hc_title(text = "Number of Individuals earning Foreign Currencies") %>%
         hc_subtitle(text = paste("Number of survey respondents earning foreign currencies, all of their compensation currency is listed to be in USD"))


## Bootstrep to check the std.error in mean of different groups
# stat<-function(x, i) {x[i, c(m1 = mean(CompensationAmount))]}
# where<-tempt[, list(list(boot(.SD, stat, R = 10))), by = CompensationCurrency]
# where$V1

```

USD is the most popular foreign currency by far for those who earn foreign currencies. Surprisingly, Ukraine, showed up right after India to as one of the more popular countries for its individuals to receive compensation in USD. I wonder if it is because some of the individuals holding top jobs in the country demand salary in USD or that this is a popular practice in certain regions

I think this list has no bearings on whether the jobs are offshored. Data science is still relatively a new field. Many companies (especially those more ambitious local ones) are currently just trying to label new position as data science/analyst when it could have been a statistician/executive job previously.


<br/>
<hr/>
<br/>

## Pay Package

In this section, we restrict ourselves to examine the paychecks of those living in US. Mainly as to how individual's education, experience, and job title influenced their compensation.

### Experience Growth

```{r}
# multipleChoiceResponses$m.CompensationAmount
multipleChoiceResponses[Tenure =="Less than a year", Tenure:="0 Less than a year" ] 

# 
dt.ExpGrowth <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[,list(.N, 
          Median=median(m.CompensationAmount),
          Q1=quantile(m.CompensationAmount, 0.25),
          Q3=quantile(m.CompensationAmount, 0.75)
  ), by =list(Tenure, m.Experience)] %>%
  .[order(m.Experience)]

# c("Less than a year", "1 to 2 years", "3 to 5 years", "6 to 10 years", "More than 10 years", "I don't write code to analyze data")
# unique(multipleChoiceResponses$EmploymentStatus)

t.WTF <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & CompensationCurrency=="USD" & !CompensationAmount==0 & EmploymentStatus == "Employed full-time"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  # .[, if(.N > 5) .SD, by=c("Tenure")] %>%
  .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[,':='(q95= quantile(m.CompensationUSD, 0.95),
          med= median(m.CompensationUSD),
          q5 = quantile(m.CompensationUSD, 0.05)), by = Tenure] %>%
  .[m.CompensationUSD<q95, ] %>%
  .[m.CompensationUSD>q5, ]

# highchart
hcboxplot(x = t.WTF$m.CompensationAmount, var = t.WTF$Tenure) %>% 
  hc_chart(type = "column")  %>%# to put box vertical
  hc_title(text = "Jobs Wages per Experience") %>%
  hc_subtitle(text = "To facilitate a fair comparison, the figures are drawn only from those fully employed in US, along with trimming of 5% and 95% of the distribution") 
```

* There exists a noticeable spike between those with experience of 3 to 5 years and 6 to 10 years. This the difference is even more significant for 10+ years, though, those with 1-2 years of experience and the entries level experience are without luck. (If we were to relate compensation to demand, does this implies that the demand at fresh graduates/new entries level has been tamed?)


<br/>
<hr/>
<br/>

### Experience & Education



```{r}
multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[,list(.N, 
          Median=median(m.CompensationAmount),
          Q1=quantile(m.CompensationAmount, 0.25),
          Q3=quantile(m.CompensationAmount, 0.75)
          ), by =list(Tenure, FormalEducation)] %>%
  .[order(FormalEducation,Tenure)]


t.WTF <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & 
      CompensationCurrency=="USD" &
      !m.CompensationAmount==0 &
      EmploymentStatus == "Employed full-time" &
      Country=="United States"] %>%
  # Additional filtering, removing some educational levels
  .[!FormalEducation %in% c("I did not complete any formal education past high school", 
                            "I prefer not to answer", 
                            NA),] %>%
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[order(Tenure)] %>%
  .[, if(.N > 5) .SD, by=c("Tenure", "m.Experience")]%>%
 .[,':='(q95= quantile(m.CompensationUSD, 0.95),
          med= median(m.CompensationUSD),
          q5 = quantile(m.CompensationUSD, 0.05)), by = c("Tenure","FormalEducation")]%>%
  .[m.CompensationUSD<q95, ] %>%
  .[m.CompensationUSD>q5, ] 

# plot of hcboxplot
hcboxplot(x = t.WTF$m.CompensationAmount, var = t.WTF$Tenure, var2 = t.WTF$FormalEducation,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # vertical plot

```

With regards to education, the level of education for "I did not complete any formal education past high school", "I prefer not to answer" and "NA" is filtered from the plot. All these levels have limited entries

In the case of "without formal education past high school", there is only a single data point at 6-10 years of experience while making $150k PA.

For those with 1-2 years into the field, it seems that the compensation does somewhat correlate with the level of education. Though, unfortunately, it seems the effect of education  ( degree level and above) is less pronounced after 6 to 10 years. Perhaps it doesn't pay to be highly educated for a long ran?

Though, please take this with a pinch of salt as DS is a new field, eventually, certain positions may simply require minimum Master's degree to even be considered ( as per other fields, the fault of specialization we have these days).


<br/>
<hr/>
<br/>

### Experience & Job Title


```{r}
# limiting to top 5 most popular job title
PopularJob <- head(AggrJobTitle$CurrentJobTitleSelect,10)

multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD" & !is.na(Tenure)] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[CurrentJobTitleSelect %in% PopularJob,] %>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by =list(Tenure, CurrentJobTitleSelect)] %>%
  .[order(CurrentJobTitleSelect, Tenure)]


t.WTF <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(m.CompensationAmount) & 
      CompensationCurrency=="USD" &
      !m.CompensationAmount==0 &
      EmploymentStatus == "Employed full-time" &
      Country=="United States"] %>%
  # Additional filtering for popular jobs
  .[CurrentJobTitleSelect %in% PopularJob,] %>%
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[order(Tenure)] %>%
  .[, if(.N > 5) .SD, by=c("Tenure", "m.Experience")]%>%
 .[,':='(q95= quantile(m.CompensationUSD, 0.95),
          med= median(m.CompensationUSD),
          q5 = quantile(m.CompensationUSD, 0.05)), by = c("Tenure","CurrentJobTitleSelect")]%>%
  .[m.CompensationUSD<q95, ] %>%
  .[m.CompensationUSD>q5, ] 


# plot of hcboxplot
hcboxplot(x = t.WTF$m.CompensationAmount, var = t.WTF$Tenure, var2 = t.WTF$CurrentJobTitleSelect,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # to put box vertical
```

*You may need to click on the legend on the plot to hide/unhide a certain categories to better identify certain category.*

While the title doesn't seem to be worthy important to learners ( in Mixed Visualisation - Job Factor section), the respective compensation one receive after years in the industry can be quite different.

Researcher and Scientist/Researcher seems to have it worst in the early years of their tenure. Although it seems some did make it big after working on it for 10 years. Data Scientist gain in compensation over the years is among the best. Especially considering that the population for Researcher and Machine Learning Engineer are small (and the fact that probably few went so far). 



<br/>
<hr/>
<br/>

## Choropleths Maps {.tabset}


Some small correction for Countrycode that is left as "NA" from the custom datasets I used.



```{r}
multipleChoiceResponses %>%
  .[Country=="Australia", CountryCode:= "AU"]%>%
  .[Country=="Russia", CountryCode:= "RS"] %>%
  .[Country=="South Korea", CountryCode:="KR"] %>%
  .[Country=="Iran", CountryCode:="IR"]%>%
  .[Country=="Belarus", CountryCode:="BR"]

```

###  Demographic Map

Colored by the value in the percentage of people looking to switch career.

* Ncount - Indicative of number of individuals 
* AgeMedian - Median Age of the population
* WorkingExpMedian - Depict the median experience of tenure/working
* WorkingP(working Population) - The percentage of those who are **"Employed full-time"**, **"Independent contractor, freelancer, or self-employed"** and **"Employed part-time"**
* LookingForJob - The Percentage of those who are **"Not employed, but looking for work"**
*StudentP - The percentage of those who labeled themselves as student


```{r}
# Aggregate the demographics for countries
t.cut<-multipleChoiceResponses[!is.na(Country),] %>%
  .[,.(NCount=.N, 
       AgeMedian = as.numeric(median(Age, na.rm=T)),
       WorkingExpMedian= signif(median(m.Experience, na.rm = T),2),
       CareerSwitcherP=signif(as.numeric(mean(CareerSwitcher=="Yes", na.rm=T)),2),
       WorkingP=signif(mean(EmploymentStatus=="Employed full-time"|
                              EmploymentStatus=="Independent contractor, freelancer, or self-employed"|EmploymentStatus=="Employed part-time", na.rm=T),2),
       LookingForJobP=signif(mean(EmploymentStatus=="Not employed, but looking for work", na.rm=T),1),
       StudentP=signif(mean(StudentStatus=="Yes", na.rm=T),2)
       ), 
  by=c("CountryCode", "Country")]
      
t.cut$iso2<- t.cut$CountryCode


# # # Plotting for highcharter map
# hcmap(mapData = worldgeojson,
#       # download_map_data=FALSE,
#       data = t.cut, value = "NCount",
#       joinBy = c("iso-a2", "CountryCode"), name = "Demography",
#       dataLabels = list(enabled = F, format = '{point.name}'), borderWidth = 1) %>%
# hc_tooltip(useHTML = TRUE,
#              headerFormat = "<table>",
#              pointFormat = paste("<tr><th colspan=\"1\"><td>{point.Country}</td></th></tr>",
#                                  "<tr><th>NCount<td>{point.NCount}</td></th></tr>",
#                                  "<tr><th>AgeMedian</th><td>{point.AgeMedian}</td></tr>",
#                                  "<tr><th>WorkingP</th><td>{point.WorkingP}</td></tr>",
#                                  "<tr><th>CareerSwitcherP</th><td>{point.CareerSwitcherP}</td></tr>",
#                                  "<tr><th>LookingForJobP</th><td>{point.LookingForJobP}</td></tr>",
#                                "<tr><th>WorkingExpMedian</th><td>{point.WorkingExpMedian}</td></tr>"),
#              footerFormat = "</table>")


highchart()%>%
  hc_add_series_map(worldgeojson, df = t.cut, value = "CareerSwitcherP", joinBy = "iso2",
                    dataLabels = list(enabled = TRUE,
                                      format = '{point.name}'), name = "Demography") %>%
hc_tooltip(useHTML = TRUE,
             headerFormat = "<table>",
             pointFormat = paste("<tr><th colspan=\"1\"><td>{point.Country}</td></th></tr>",
                                 "<tr><th>NCount<td>{point.NCount}</td></th></tr>",
                                 "<tr><th>AgeMedian</th><td>{point.AgeMedian}</td></tr>",
                                 "<tr><th>WorkingP</th><td>{point.WorkingP}</td></tr>",                                 "<tr><th>CareerSwitcherP</th><td>{point.CareerSwitcherP}</td></tr>",
                                 "<tr><th>LookingForJobP</th><td>{point.LookingForJobP}</td></tr>",
                               "<tr><th>WorkingExpMedian</th><td>{point.WorkingExpMedian}</td></tr>"),
             footerFormat = "</table>")

```

###  Compensation and JobTitle Percentage Map 

Colored by the value in respective country local currencies, a easier way for individuals around the world to gauge their salaries.

* LocalPay.Med -$[CurrencyCode]$ Median pay in local currency of that country. (Q1-Q3)
* USDPay.Med - Median pay in USD
* DS_P - Percentage of people who choosed Data Sciencist as their Current Job Title
* Research_P - Percentage of people who choosed Researcher/Scientist as their Current Job Title


```{r}
# Aggregate the demographics for countries
t.cut<-multipleChoiceResponses[!is.na(Country),] %>%
  .[,.(NCount=.N, 
       CompensationLocal_Median = as.numeric(median(m.CompensationLocal, na.rm=T)),
       CompensationLocal_Q3= signif(quantile(m.CompensationLocal, 0.75, na.rm = T),2),
       CompensationLocal_Q1=signif(quantile(m.CompensationLocal,0.25, na.rm=T),2),
       CompensationUSD_Median = as.numeric(median(m.CompensationUSD, na.rm=T)),
       CompensationUSD_Q3=signif(quantile(m.CompensationUSD, 0.75, na.rm = T),2),
       CompensationUSD_Q1=signif(quantile(m.CompensationUSD,0.25, na.rm=T),2),
       DS_P=signif(mean(CurrentJobTitleSelect=="Data Scientist", na.rm=T)*100,2),
       Research_P=signif(mean(CurrentJobTitleSelect=="Researcher" | CurrentJobTitleSelect=="Scientist/Researcher ", na.rm=T)*100,1)
       ), 
  by=c("CountryCode", "Country", "Code")]
      
t.cut$iso2<- t.cut$CountryCode

highchart()%>%
  hc_add_series_map(worldgeojson, df = t.cut, value = "CompensationLocal_Median", joinBy = "iso2",
                    dataLabels = list(enabled = TRUE,
                                      format = '{point.name}'), 
                    name = "Compensation and JobTitle Percentage Map") %>%
hc_tooltip(useHTML = TRUE,
             headerFormat = "<table>",
             pointFormat = paste("<tr><th colspan=\"1\"><td>{point.Country}</td></th></tr>",
                                 "<tr><th>LocalPay.Med<td>[{point.Code}] {point.CompensationLocal_Median}({point.CompensationLocal_Q1}-{point.CompensationLocal_Q3})</td></th></tr>",
                             
                                 "<tr><th>USDPay.Med</th><td>$ {point.CompensationUSD_Median}({point.CompensationUSD_Q1}-{point.CompensationUSD_Q3})</td></tr>",
                                 "<tr><th>DS_P</th><td>{point.DS_P}%</td></tr>",
                               "<tr><th>Research_P</th><td>{point.Research_P}%</td></tr>"),
             footerFormat = "</table>")