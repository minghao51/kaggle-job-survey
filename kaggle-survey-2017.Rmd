---
title: "kaggle-survey"
author: "minghao"
date: "October 21, 2017"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    df_print: tibble
---

# Libraries
```{r, warning = FALSE, message=FALSE}
require(tidyverse)
require(data.table)
require(lubridate)
require(stringr)
require(ggvis)
require(ggplot2)
require(forcats)
require(ggmap)
require(highcharter)
require(broom)
require(plotly)

#NLP
require(quanteda)
require(wordcloud)
require(slam)

#map
require(leaflet)



require(igraph)
```

Note that I made extensive use of data.table to extract, filter, process the data as that's the method that I'm most conformable with.

# Data Input

The following are data provided by Kaggle

```{r}

conversionRates <- as.data.table(read.csv(file="conversionRates.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = FALSE))

freeformResponses <- as.data.table(read.csv(file="freeformResponses.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = FALSE))

multipleChoiceResponses <- as.data.table(read.csv(file="multipleChoiceResponses.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = TRUE))

schema <- as.data.table(read.csv(file="schema.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = FALSE))

```

Some custom data that I used

```{r}
## Rcurl into data method
# library(RCurl)
# x <- getURL("https://gist.githubusercontent.com/marcusbaguley/304261/raw/0ab501897ce32fcd3aecd748b74686a20ada9036/Country%2520Currency%2520Code%2520Mappings")
# y <- read.csv(text = x)

## Reading downloaded csv method
currency2CountryName <- data.table(read.csv("Country Currency Code Mappings.csv"))
```


```{r}
highchart() %>% 
  hc_yAxis_multiples(
    list(lineWidth = 3),
    list(showLastLabel = FALSE, opposite = TRUE)
  ) %>% 
  hc_add_series(data = rnorm(10)) %>% 
  hc_add_series(data = rexp(10), type = "spline", yAxis = 1)
```

# Function

```{r}
# To extract the patterns of response that would follow a similar pattern on counts per value
MultipleChoice_func = function(question, dt = multipleChoiceResponses){
  
  setDT(dt) %>%
    # since the dt contained column with similar name, selecting only these column
    .[, colnames(.) %like% question, with=FALSE] %>%
    # melting wide data into long data
    melt(.,measure.vars=patterns(question), na.rm = TRUE, variable.name=question) %>%
    # Shortening the str with str_extract
    .[, eval(question):=str_extract(get(question), paste0("(?<=",eval(question),")([A-Za-z])*"))] %>%
    # Aggregate the counts
    .[,list(N=.N),
            by=c(eval(question), "value")] %>%
    .[, percentage := N/sum(N)] %>%
  # The output should be plotted and processed, the numbers are already aggregated
    .[order(-N)]
}

# For some survey question that allow multiple choices ( select all that apply), the results are stored in a str list that seperated by ",", this function serve to extract it
MultipleChoiceOptions_func = function(question, dt = multipleChoiceResponses){
  
  # Turning this column into characters
  dt[, (question):= lapply(.SD, as.character ), .SDcols = question ]
  
  # I couldn't get there expresssion to change to with as.character nicely
  # `$`(df , question)<-as.character(`$`(df , question))
  # dt[,get(question)] <- as.character(dt[,get(question)])
  
  # Detecting the appropriate number of split
  t.splits <- max(lengths(strsplit(dt[,get(question)], '\\([^)]+,(*SKIP)(*FAIL)|,\\s*', 
                                   perl = TRUE)))
  
  # t.splits
  t.test <- dt[,.(get(question))] %>%
    .[, paste0("m.", eval(question),
               1:t.splits):=tstrsplit(V1,
                                      '\\([^)]+,(*SKIP)(*FAIL)|,\\s*',
                                      perl = TRUE)] %>%
    .[, colnames(.) %like% "m.*", with=FALSE] %>%
    melt(.,  measure.vars = patterns("^m.*"), na.rm = T) %>% #note that na is removed
  # This output two column by default, with value column correspodings to the individual strings. Should be processed use with aggregation.
        # Aggregate the counts
    .[,.N, by=c("value")] %>%
  # The output should be plotted and processed, the numbers are already aggregated
    .[order(-N)]
}

Wordclourd_func = function(input, dt = freeformResponses){
  
  # Creating a document-feature matrix
  dfm.txt <- dfm(eval(dt)[!is.na(get(input)), get(input)],
                remove=stopwords("english"),
                remove_symbols = T,
                remove_punct = T,
                remove_numbers = T,
                remove_url = T,
                ngrams=1:2)
  
  ## Rowsum to find individual term's frequency across all documents
  term_frequency<-row_sums(t(dfm.txt)) # This utilised row_sum
  
  ## Create word_freqs
  word_freqs <- data.frame(term = names(term_frequency), num = term_frequency)
  word_freqs
  
  # for starters, word_freqs(basically a df with terms and its frequency) can be processed with wordcloud and barplot
}

```

# Basic visualisation

This section depicts the some basic plots of survey, which could be used to explore the cross section data analysis with it's tabbed structure. 

Initially,  I intended to look at into Pay vs Experience and Demographics of countries, but it has since grown up a bit.

## Countries 

```{r}
# Merging the records of country for China
# in the raw data, China seems to be recorded as "People 's Republic of China", "Republic of China"
multipleChoiceResponses<-multipleChoiceResponses[grep("China",Country), Country:= "China"]

# Dropping it from factors too
multipleChoiceResponses<-droplevels(multipleChoiceResponses)

# plotting
hchart(fct_infreq(multipleChoiceResponses$Country), "column") %>%
  hc_title(text = "Respondent's Country ",
             style = list(color = "Black", useHTML = TRUE)) %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="Country", Asked]),"]",
                           eval(schema[Column=="Country", Question]),
                           "<br>Countries with < 50 counts are aggregated into Other"),
             style = list(color = "Black", useHTML = TRUE)) %>%
  hc_xAxis(text = "Countries", labels = list(rotation = 90))
  
```
Merged the records of country for China (People 's Republic of China", "Republic of China). Also,  there are seperate entries for selection of Taiwan and Hong Kong. So while it may vary depending on your definition, the sum of the three entries would make it the third countries with most survey respondents, just after India.

Overall, the majority of the surveyed users are living in US and India. Interestingly, many users also selected "Others" categories ( Or perhaps their country is less represented in the data). Given that this is the survey result on Kaggle, this is probably little surprise. There might exist other data science platforms that are more popular in Other countries, especially if that country favor another language(China, Japan, Germany).

## Tenure

Tenure can probably be related to Working Experience, although, given that the question of tenure is directed to all,, this is a hazy indicator given that some might include their years of coding in their education (which typically isn't included in the years of working experience). There is no better alternative in exploring working experience though.

```{r}
hchart(fct_infreq(multipleChoiceResponses$Tenure), "column")%>%
  hc_title(text = "Tenure") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="Tenure", Asked]),"]",
                           eval(schema[Column=="Tenure", Question])
                           ))

# Create a numeric column indicative of current tenure selections
# essentially a host of if, then case to set a numeric value fr m.Tenure
multipleChoiceResponses %>%
  .[Tenure=="3 to 5 years", m.Experience :=4] %>%
  .[Tenure=="6 to 10 years", m.Experience :=8] %>%
  .[Tenure=="1 to 2 years", m.Experience :=2] %>%
  .[Tenure=="More than 10 years", m.Experience :=12]%>% 
  #~hand wavingly, though data science being a relatively young field and that the majority of survey user are in their late 20s or early 30, this figures should be alright
  .[Tenure=="Less than a year", m.Experience :=0] %>%
  .[Tenure=="I don't write code to analyze data", m.Experience :=NA]
# perhaps these people rely on tableau and the likes, in any case, this field would not be indicate of their experience in their profession, removing it

## check
# unique(multipleChoiceResponses[,.(m.Experience, Tenure)])
```

## Code Writer 

```{r}
hchart(fct_infreq(multipleChoiceResponses$CodeWriter), "column")%>%
  hc_title(text = "CodeWriter") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="CodeWriter", Asked]),"]",
                           eval(schema[Column=="CodeWriter", Question])
                           ))
```

Interestingly, about one third of people dont work with codes. I can only think of three posible reasons, one is that they are moved up into project management roles that dont require them to work with codes. Second, they working in more of a analyst role dealing with the likes of tableau/excel or other data analyst software that dont require codes. Alternatively, it is possible that they are working in another field, and are looking to break into data science.


## Job Title

```{r}
hchart(fct_infreq(multipleChoiceResponses$CurrentJobTitleSelect), "column")%>%
  hc_title(text = "Job Title") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="CurrentJobTitleSelect", Asked]),"]",
                           eval(schema[Column=="CurrentJobTitleSelect", Question])
                           ))


## Creating a list of Popular job title - Aggregate Job Title
## to be use in later section
AggrJobTitle <- multipleChoiceResponses %>%
  .[!is.na(CurrentJobTitleSelect)&!CurrentJobTitleSelect=="Other",
                        .N, 
    by = CurrentJobTitleSelect] %>%
  .[order(-N)]
```

Evidently, Data Scientist, Software Developer, Data analyst and Scientist/Researh are most popular. I  am puzzle by what is the difference between Scientist/Research and Research (Maybe Education might shed a light?), perhaps they should be aggregated into a single option? Though in that case they will be the 3rd most popular job title, even before Data analyst



## Past Job title

###Select

```{r}
t.WTF <- MultipleChoiceOptions_func("PastJobTitlesSelect")
  
hchart(t.WTF, type="column", hcaes(x = value, y = N, group = value),
                                   options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
         hc_title(text = "PastJobTitlesSelect") %>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="PastJobTitlesSelect", Asked]),"]",
                                  eval(schema[Column=="PastJobTitlesSelect", Question])
         ))

```
 
### FreeForm

```{r}
## freeformResponse
# colnames(freeformResponses)
nrow(freeformResponses[!is.na(PastJobTitlesFreeForm)])
# 2094

t.WTF<-setDT(Wordclourd_func("PastJobTitlesFreeForm")) %>%
  .[order(-num)] %>%
  .[num>20,] %>%
  .[, percent:=num/sum(num)*100, ]
  

hchart(t.WTF, type="column", hcaes(x = term, y = num))


highchart() %>%   
  hc_add_series(t.WTF, "column", hcaes(x = term, y = num), name = "column") %>%
  hc_add_series(t.WTF, "pie", hcaes(name = term, y = percent), name = "Bars")
```

## Job Factor

```{r}
t.WTF <-MultipleChoice_func("JobFactor")

hchart(t.WTF, type="column", hcaes(x = JobFactor, y = N, group = value),
                                   options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
         hc_title(text = "JobFactor") 


per.dt<-t.WTF %>%
  .[, .(percent=sum(percentage)), by = JobFactor]


highchart() %>%   
  hc_add_series(t.WTF, "column", hcaes(x = JobFactor, y = N, group = value), name = "column") %>%
  hc_add_series(per.dt, "pie", hcaes(name = JobFactor, y = percent), name = "Bars") %>% 
   # Optiosn for each type of series
  hc_plotOptions(
    series = list(
      showInLegend = FALSE,
      pointFormat = "{point.y}%"
    ),
    pie = list(
      colorByPoint = TRUE, center = c('30%', '10%'),
      size = 120, dataLabels = list(enabled = FALSE)
    )) %>%
  # Axis
  hc_xAxis(categories = t.WTF$JobFactor) %>%
  #Title & Subtitle
         hc_title(text = "JobFactor") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="JobFactor", Asked]),"]",
                           eval(schema[Column=="JobFactor", Question])
                           ))

```
 The Majority learners seems to think that their Job title are a somewat important. Although surprisingly, not all of the learners hold job title in an important place

## Age

```{r}
hchart(multipleChoiceResponses$Age, na.rm =T)%>%
    hc_title(text = "Age") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="Age", Asked]),"]",
                           eval(schema[Column=="Age", Question])
                           ))
```

As noted by other kernals, most the respondents of the survey are young, most likely in their mid 20s.

```{r}
# highchart() %>%
#   hc_add_series(density(multipleChoiceResponses[!is.na(Age),Age])) %>%
#   hc_xAxis(plotLines = list(
#     list(
#       value = median(multipleChoiceResponses[!is.na(Age),Age]),
#       color = '#ff0000',
#       width = 3,
#       zIndex = 4,
#       label = list(text = paste("Median:", median(multipleChoiceResponses[!is.na(Age),Age])),
#                    style = list( color = '#ff0000', fontWeight = 'bold' )
#       )),
#     list(
#       value = quantile(multipleChoiceResponses[!is.na(Age),Age], 0.75)[[1]],
#       color = '#ff0000',
#       width = 3,
#       zIndex = 4,
#       label = list(text = paste("Q3:", quantile(multipleChoiceResponses[!is.na(Age),Age], 0.75)[[1]]),
#                    style = list( color = '#ff0000', fontWeight = 'bold' )
#       )),
#     list(
#       value = quantile(multipleChoiceResponses[!is.na(Age),Age], 0.25)[[1]],
#       color = '#ff0000',
#       width = 3,
#       zIndex = 4,
#       label = list(text = paste("Q1:", quantile(multipleChoiceResponses[!is.na(Age),Age], 0.25)[[1]]),
#                    style = list( color = '#ff0000', fontWeight = 'bold' )
#       ))))
```

## Career Switcher

```{r}
hchart(fct_infreq(multipleChoiceResponses$CareerSwitcher), na.rm =T,
       options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
    hc_title(text = "CareerSwitcher") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="CareerSwitcher", Asked]),"]",
                           eval(schema[Column=="CareerSwitcher", Question])
                           ))
```

## Salary Change

```{r}
hchart(fct_infreq(multipleChoiceResponses$SalaryChange), na.rm =T,
       options3d = list(enabled = TRUE, beta = 1, alpha = 1)) %>%
    hc_title(text = "SalaryChange") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="SalaryChange", Asked]),"]",
                           eval(schema[Column=="SalaryChange", Question])
                           ))
```

wow, most people saw a 20% increase in salary over 3 years. Guess Data science is indeed a field in demand.



## Remote Work

```{r}
hchart(multipleChoiceResponses$RemoteWork, na.rm =T)%>%
    hc_title(text = "RemoteWork") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="RemoteWork", Asked]),"]",
                           eval(schema[Column=="RemoteWork", Question])
                           ))
```

## Currency

Sadly, the conversionRates provided gave only "OriginCountry" (USD, EUR, AUD etc) and "conversionRates"  (in numerics with USD as base line). I find the "OriginCountry" to be somewat misleading, as it is more of a Currency Code than Country.

One will have to relate that to Country Name before joining the ConversionRates into multipleChoiceResponses. The following codes attempts several joins

conversionRates -> currency2CountryName -> multipleChoiceResponses
(where -> = join into ).

```{r}
# # Cleaning up Conversion Rates, removing X which seems to be a raw ID
conversionRates$X=NULL

# # Renaming conversionRates to facillate easier join
colnames(conversionRates) <- c("Code", "ExchangeRate")

# # joining currency2CountryName and conversionRates together
Currency2CountryConversion <- currency2CountryName[conversionRates, on=.(Code)]

# # Converting country code into character
# # Currency2CountryConversion$CountryCode <- as.character(Currency2CountryConversion$CountryCode)
multipleChoiceResponses$CompensationAmount <- as.numeric(as.character(multipleChoiceResponses$CompensationAmount))

# # It seems Currency2CountryConversion has some NA/nonunique value for Country Name and Code
# glimpse(unique(Currency2CountryConversion[is.na(Country)]))
# $ Country      <fctr> NA, NA, NA, NA
# $ CountryCode  <fctr> NA, NA, NA, NA
# $ Currency     <fctr> NA, NA, NA, NA
# $ Code         <fctr> RSD, BAM, BYN, GHS
# $ ExchangeRate <dbl> 0.010020, 0.611383, 0.518071, 0.225710
# # Removing them as this will cause duplicates when merging
Currency2CountryConversion <- Currency2CountryConversion[!is.na(Country)]

# # Combining the main dt with Currency2Country
multipleChoiceResponses <- Currency2CountryConversion[] %>%
  .[multipleChoiceResponses, on=.(Country)] %>%
  # # Create a column that account for the conversion rate of local currencies
  .[!is.na(CompensationAmount), m.CompensationLocal:= CompensationAmount * ExchangeRate]

# # Changing columns into as.character to facillitate comparison for later section
multipleChoiceResponses[, c("Code", "CompensationCurrency"):=lapply(.SD, as.character), .SDcols=c("Code", "CompensationCurrency")]

# class(multipleChoiceResponses$CompensationCurrency)

# Comparison
# unique(multipleChoiceResponses[CompensationCurrency==Code,.(CompensationCurrency, Code)])
```

## Learning Platform Select
```{r}
schema[Column=="LearningPlatformSelect", Question]

t.WTF <- MultipleChoiceOptions_func("LearningPlatformSelect") 


hchart(t.WTF, type="column", hcaes(x = value, y = N, group = value),
                                   options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
         hc_title(text = "LearningPlatformUsefulness") %>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="LearningPlatformSelect", Asked]),"]",
                                  eval(schema[Column=="LearningPlatformSelect", Question])
                                  ))


```

## Learning Platform Usefulness

```{r}
schema[Column=="LearningPlatformUsefulness", Question]

t.WTF <- MultipleChoice_func("LearningPlatformUsefulness") 

hchart(t.WTF, type="column", hcaes(x = LearningPlatformUsefulness, y = N, group = value),
                                   options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
         hc_title(text = "LearningPlatformUsefulness") 
         # hc_subtitle(text = paste("Q",
         #                          "[",eval(schema[Column=="LearningPlatformUsefulness", Asked]),"]",
         #                          eval(schema[Column=="LearningPlatformUsefulness", Question])
         # ))
```

## Work tools Frequency

```{r}
t.WTF <- MultipleChoice_func("WorkToolsFrequency") 
hchart(t.WTF, type="column", hcaes(x = WorkToolsFrequency, y = N, group = value))
```

## Proving your worth for learners


```{r}
t.WTF <- MultipleChoice_func("ProveKnowledge") 
hchart(t.WTF, type="column", hcaes(x = ProveKnowledge, y = N, group = value))%>%
    hc_title(text = "ProveKnowledge") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="ProveKnowledgeSelect", Asked]),"]",
                           eval(schema[Column=="ProveKnowledgeSelect", Question])
                           ))
```

Its equivalent freeform form of data, however, are overwhelming pointing towards projects. Although limited people proceed to free writing this.


## Algorithm Understanding

```{r}
t.WTF <- MultipleChoice_func("AlgorithmUnderstandingLevel") 
hchart(t.WTF, type="column", hcaes(x = value, y = N, group = value)) %>%
    hc_title(text = "AlgorithmUnderstandingLevel") %>%
  hc_subtitle(text = paste("Q","[",eval(schema[Column=="AlgorithmUnderstandingLevel", Asked]),"]",
                           eval(schema[Column=="AlgorithmUnderstandingLevel", Question])
                           ))

```



# Interesting combination

## Network Graph of Career Change
If we draw a network graph assuming therea connection between past job(s) and current job.

```{r}

# Making sure that this column is in characters
JobNetworkPlot_dt <- multipleChoiceResponses[, PastJobTitlesSelect:=lapply(.SD, as.character ), .SDcols = c("PastJobTitlesSelect") ] %>%
  # Selecting only relevent columns of "CurrentJobTitleSelect" and "PastJobTitlesSelect"
  .[,colnames(.) %in% c("PastJobTitlesSelect", "CurrentJobTitleSelect"), with = FALSE] 

# CareerSwitcher

t.splits <- max(lengths(strsplit(JobNetworkPlot_dt$PastJobTitlesSelect, '\\([^)]+,(*SKIP)(*FAIL)|,\\s*', perl = TRUE)))

t.test123 <- JobNetworkPlot_dt %>%
  # There are respondents that gave a list of previous job titles, yet did not have their current job title recorded, the past job titles select would still hold valueble data. For these people,chanaging their Current JobTitle to "Not Given" 
  .[is.na(CurrentJobTitleSelect), CurrentJobTitleSelect:="Not given"] %>%
  # strsplit the past job title select base on ","
  .[, paste0("m.PastJobTitlesSelect",
             1:t.splits):=tstrsplit(PastJobTitlesSelect,
                                    '\\([^)]+,(*SKIP)(*FAIL)|,\\s*',
                                    perl = TRUE)] %>%
  melt(.,  measure.vars = patterns("^m.*"), na.rm = T) %>%
    # Removing those who arent/ havent start working
    .[!value=="I haven't started working yet"] %>%
  .[,(colnames(.) %in% c("CurrentJobTitleSelect", "value")),with = F] %>%
  .[,list(weight=.N), by = c("CurrentJobTitleSelect", "value")]

  
  ## make graph
# g <- graph_from_edgelist(t.test123, directed=FALSE)

net<-graph_from_data_frame(d=t.test123,directed=T) 

net <- simplify(net, remove.multiple = F, remove.loops = T) 

plot(net, edge.arrow.size=.4,vertex.label=NA)

plot(net, edge.arrow.size=.4,layout=layout_in_circle, vertex.label=NA, edge.width=E(net)$weight/200)

# plot(net, edge.arrow.size=.4,layout=layout_in_star, vertex.label=NA, edge.width=E(net)$weight/200)

```




## Currency & Remote work
Having combined the the compensation currency and currency code for supposed country that the respondents are living, I wonder if all these people who are receiving foreign currency were doing mostly remove work?

```{r}
t.WTF<-multipleChoiceResponses[!is.na(CompensationCurrency)& CompensationCurrency!= Code,
                               .N, 
                               by=c("RemoteWork", "Country")] %>%
  .[order(-RemoteWork)]


hchart(t.WTF, type="column", hcaes(x = Country, y = N, group = RemoteWork)) %>%
hc_title(text = "Currency & Remote work") 


```


## Codes & Job Title

```{r}
t.WTF<-multipleChoiceResponses[!is.na(CurrentJobTitleSelect)] %>%
  .[, .N, by=.(CurrentJobTitleSelect, CodeWriter)] %>%
  .[order(-N)]

hchart(t.WTF, type="column", hcaes(x = CurrentJobTitleSelect, y = N, group = CodeWriter)) %>%
hc_title(text = "Coders with relation to Job Title") 

```

Well, it seems close to half of the Software Enginer dont write codes? That's strange.

In case for Business Analyst and Data Analyst, the amount of non coders could maybe be attribute to their dealing with other statistical software. Perhaps some of the jobs still involve around good old excel.


## Deeper water

Lets look at Software Enginer in depth, seeing that they don't code as much

```{r}
# Typically, we are restricted to 3 dimensional plots, x, y, group. 
# though, there are also the paste-combine trick
NonCodersTitle<-c("Software Developer/Software Engineer", "Business Analyst", "Programmer")

t.WTF<-multipleChoiceResponses[!is.na(CurrentJobTitleSelect)]%>%
  # selecting only NoncodersTitle
  .[CurrentJobTitleSelect %in% NonCodersTitle ] %>%
  .[, Combined:=paste(CurrentJobTitleSelect,"-", Tenure)]%>%
  .[, .N, by=.(Combined, CurrentJobTitleSelect, CodeWriter)] %>%
  .[order(Combined, -N)] 

hchart(t.WTF, type="column", hcaes(x = Combined, y = N, group = CodeWriter))

```


In both three case, it seems that Business Analyst, Programmers and Software engineer can enter the their respect filed without being an actual coder. Since, there exist a significant amount of non coders in these jobs. However, the ratio of coders to non coders increase as people work through their tenure and grow in experience.

I find such low requirement to entry a bit hard to believe, it seems that these professions are  good staging ground for those who are intending venture into Data Science (if you are a bit weak on the codes/programming side), especially if you are from another field.

Evidently, some business analyst roles dont require coding.

On the other hand, the fabled "manager role" that dont require coding is elusive on these profesions.


Please take all this with a pitch of salt, as the environment is rapidly changing, espeacially in the field of data science.


```{r}
t.WTF<-multipleChoiceResponses[]%>%
  .[!is.na(CurrentJobTitleSelect) & CurrentJobTitleSelect=="Business Analyst"] %>%
  .[, .N, by=.(CurrentJobTitleSelect, CodeWriter, Tenure)] %>%
  .[order(CurrentJobTitleSelect, -N)]

hchart(t.WTF, type="column", hcaes(x = Tenure, y = N, group = CodeWriter))
```
## Country vs Compensation Currency, Compensation Amount

### US

```{r}
# Turning CompensationAmountfrom factor into numeric column
multipleChoiceResponses$CompensationAmount <- as.numeric(as.character(multipleChoiceResponses$CompensationAmount))

# Checking if there is significant difference between listing of different of different currecies
multipleChoiceResponses%>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount)]%>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",.(CompensationAmount,CompensationCurrency)] %>%
  # There exist individuals who are taking foreign currency, perhaps they are doing remote work or working overseas? In any case,
  .[, if(.N >10) .SD, by = list(CompensationCurrency)]%>%
  # filtering out those with absurd compensation amount, there are two with 0 or hundreds, selecting only those greater than 10000 (perhaps they are taking internships?)  
  .[CompensationAmount>10000,] %>%
    .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by=CompensationCurrency]

# From the quantile value (Q1 - Q3) in this case, I think one can safetly assume that the salary of those living in US can be changed to USD.

# Change the Compensation Currency of those living in US yet did not select a currency into USD
multipleChoiceResponses[!is.na(CompensationAmount)&is.na(CompensationCurrency)&Country=="United States", CompensationCurrency:="USD"]

multipleChoiceResponses[!is.na(CompensationAmount),.N,by = c("Country", "CompensationCurrency")] %>%
  .[order(-N)] %>%
  .[Country=="United States"]


multipleChoiceResponses[!is.na(CompensationAmount)]%>%
  .[Country=="United States",] %>%
  .[,.N,by = c("CompensationCurrency")] 

##bootstrep to check the std.error in mean of different groups
# stat<-function(x, i) {x[i, c(m1 = mean(CompensationAmount))]}
# where<-tempt[, list(list(boot(.SD, stat, R = 10))), by = CompensationCurrency]
# where$V1

```

### India

```{r}

multipleChoiceResponses[!is.na(CompensationAmount),.N,by = c("Country", "CompensationCurrency")] %>%
  .[order(-N)] %>%
  .[Country=="Russia"]


multipleChoiceResponses[!is.na(CompensationAmount),.N,by = c("Country", "CompensationCurrency")] %>%
  .[order(-N)] %>%
  .[Country=="India"]


multipleChoiceResponses%>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount)]%>%
  # Filtering for India, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="India",.(CompensationAmount,CompensationCurrency)] %>%
  # There exist individuals who are taking foreign currency, perhaps they are doing remote work or working overseas? In any case,
  .[, if(.N >10) .SD, by = list(CompensationCurrency)]%>%
  # filtering out those with absurd compensation amount, there are two with 0 or hundreds, selecting only those greater than 10000 (perhaps they are taking internships?)  
  # .[CompensationAmount>10000,]%>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by=CompensationCurrency]

#in this case, the Q1 of those with did not selected currency are significantly different in Q1, given that there are some people who noted that they received USD for compensation, and that we have 443 case of people recieving INR, I think we should err on the safe side and discard those records that did not specified currency for the purpose of compensation analysis.

# This holds true for other countries, where is probably more significant given smaller sample size.

# Ops, it looks like the some people did not select their currency of compensation. There is also a host of people recieving foreign currency ( I wonder if they are doing remote work)
# 
# Though, since we are provided with a .csv of conversion rates and OriginCountry name, lets proceed with joining it together and check if the names match
```

## Pay Package

### Experience Growth

```{r}
multipleChoiceResponses[Tenure =="Less than a year", Tenure:="0 Less than a year" ]

# multipleChoiceResponses$m.Experience

multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by =list(Tenure, m.Experience)] %>%
  .[order(m.Experience)]


# c("Less than a year", "1 to 2 years", "3 to 5 years", "6 to 10 years", "More than 10 years", "I don't write code to analyze data")
unique(multipleChoiceResponses$EmploymentStatus)

t.WTF <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD" & !CompensationAmount==0 & EmploymentStatus == "Employed full-time"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  #Need to be named explicitly since highcharter would label it as "series x"if the column name is NA
  .[is.na(Tenure), Tenure:= "Not Selected"] %>%
  .[order(Tenure)] %>%
  .[, if(.N > 5) .SD, by=c("Tenure", "m.Experience")]
  # arrange(desc(Tenure)) 


hcboxplot(x = t.WTF$CompensationAmount, var = t.WTF$Tenure,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # to put box vertical


# hchart(t.WTF, type="boxplot", hcaes(x = CompensationAmount, y = Tenure))
```

### Experience & Education

It seems only reasonable to restrict pay packages to individual country (or cities) and local currency.


```{r}
multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by =list(Tenure, FormalEducation)] %>%
  .[order(FormalEducation,Tenure)]

# plot of hcboxplot
hcboxplot(x = t.WTF$CompensationAmount, var = t.WTF$Tenure, var2 = t.WTF$FormalEducation,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # to put box vertical

```

### Experience & Job Title

Salary with respect to job title and tenure

```{r}
# limiting to top 5 most popular job title
PopularJob <- head(AggrJobTitle$CurrentJobTitleSelect,5)

multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD" & !is.na(Tenure)] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[CurrentJobTitleSelect %in% PopularJob,] %>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by =list(Tenure, CurrentJobTitleSelect)] %>%
  .[order(CurrentJobTitleSelect, Tenure)]


# plot of hcboxplot
hcboxplot(x = t.WTF$CompensationAmount, var = t.WTF$Tenure, var2 = t.WTF$CurrentJobTitleSelect,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # to put box vertical
```

## Proven Knowledge Select

```{r}

t.WTF <- MultipleChoiceOptions_func("ProveKnowledgeSelect") 


hchart(t.WTF, type="column", hcaes(x = value, y = N, group = value),
                                   options3d = list(enabled = TRUE, beta = 1, alpha = 1))%>%
         hc_title(text = "ProveKnowledgeSelect") %>%
         hc_subtitle(text = paste("Q",
                                  "[",eval(schema[Column=="ProveKnowledgeSelect", Asked]),"]",
                                  eval(schema[Column=="ProveKnowledgeSelect", Question])
                                  ))
```


## Proven Knowledge FreeForm



```{r}
# nrow(freeformResponses[!is.na(ProveKnowledgeFreeForm)])
# 122

word_freqs <- Wordclourd_func("ProveKnowledgeFreeForm")
wordcloud(word_freqs$term, word_freqs$num, max.words = 100,
           random.order=FALSE, colors=brewer.pal(8,"Dark2"), rot.per=.3, scale=c(3,.5))
```

# Impactful Algorithm FreeForm

```{r}
# Checking the valid number of input
# nrow(freeformResponses[!is.na(ImpactfulAlgorithmFreeForm)])
# 4379

# ImpactfulAlgorithmFreeForm
word_freqs <-  Wordclourd_func("ImpactfulAlgorithmFreeForm")
wordcloud(word_freqs$term, word_freqs$num, max.words = 100,
           random.order=FALSE, colors=brewer.pal(8,"Dark2"), rot.per=.3, scale=c(3,.5))

```


# Choropleths Map

# Currency Codes & Country Name & highcharter Map

```{r}
#loading world-geojson that is part of highcharter
data(worldgeojson)

#plotting for highcharter map
hcmap(mapData = worldgeojson, 
      download_map_data=F, data = Currency2CountryConversion, value = "ExchangeRate",
      joinBy = c("iso-a2", "CountryCode"), name = "Demography",
      dataLabels = list(enabled = F, format = '{point.name}'), borderWidth = 1,
      tooltip = list(valueDecimals = 2, valuePrefix = "$", valueSuffix = " USD")) 
```

# Highcharter maps and geocodes

```{r}
# making a list of file in current working directory
filelist <- list.files()

# if.rds exist, read it , otherwise, identify lat lon for the countries
if(any(filelist=="Country2latlon.rds")){
  # read the created .rds containing the require data
  Country2latlon <- readRDS("Country2latlon.rds")
  colnames(Country2latlon)<- c("CountryName", "lon", "lat")
}else{
  # create a new .rds using geocode to estimate lat and lon of every country
  geocodes <- geocode(as.character(unique(multipleChoiceResponses[!is.na(Country)]$Country)))
  Country2latlon <- data.frame("CountryName" = as.character(unique(multipleChoiceResponses[!is.na(Country)]$Country)),
                               geocodes)
  saveRDS(Country2latlon, "Country2latlon.rds")
}

mapdata <- get_data_from_map(download_map_data("custom/world-highres"))

# glimpse(mapdata)
# $ `hc-group`       <chr> "admin0", "admin0", "admin0", "admin0", "admin0", "admin0", "admin0"...
# $ `hc-middle-x`    <dbl> 0.66, 0.57, 0.70, 0.51, 0.58, 0.33, 0.29, 0.50, 0.41, 0.86, 0.54, 0....
# $ `hc-middle-y`    <dbl> 0.41, 0.58, 0.68, 0.65, 0.41, 0.44, 0.05, 0.52, 0.55, 0.57, 0.51, 0....
# $ `hc-key`         <chr> "fo", "um", "us", "jp", "sc", "in", "fr", "fm", "cn", "sw", "sh", "b...
# $ `hc-a2`          <chr> "FO", "UM", "US", "JP", "SC", "IN", "FR", "FM", "CN", "SW", "SH", "B...
# $ name             <chr> "Faroe Islands", "United States Minor Outlying Islands", "United Sta...
# $ labelrank        <chr> "6", "5", "2", "2", "6", "2", "2", "6", "2", "5", "6", "2", "3", "2"...
# $ `country-abbrev` <chr> "Faeroe Is.", "U.S. MOI", "U.S.A.", "Japan", "Syc.", "India", "Fr.",...
# $ subregion        <chr> "Northern Europe", "Seven seas (open ocean)", "Northern America", "E...
# $ `region-wb`      <chr> "Europe & Central Asia", "East Asia & Pacific", "North America", "Ea...
# $ `iso-a3`         <chr> "FRO", "UMI", "USA", "JPN", "SYC", "IND", "FRA", "FSM", "CHN", "-99"...
# $ `iso-a2`         <chr> "FO", "UM", "US", "JP", "SC", "IN", "FR", "FM", "CN", "SW", "SH", "B...
# $ `woe-id`         <chr> "23424816", "28289407", "23424977", "23424856", "23424941", "2342484...
# $ continent        <chr> "Europe", "North America", "North America", "Asia", "Seven seas (ope...
```

```{r}
# Quick check for uniqueness in Country2latlon by respective longitude and latitude
nrow(unique(setDT(Country2latlon), by=c("lon", "lat")))==nrow(Country2latlon)

# Wow, apparently, geocode gives the same lat and lon for Taiwan and China 
setDT(Country2latlon)[CountryName=="Republic of China"| CountryName=="Taiwan",]

# The Mapdata also does not offer seperate entry for Taiwan,
# lets go for the easier way out - combining them as similar entities.
multipleChoiceResponses <- multipleChoiceResponses[
  Country=="Republic of China"| Country=="Taiwan", Country:="China"]

# Dropping Taiwan from main data too
multipleChoiceResponses$Country<-droplevels(multipleChoiceResponses$Country)

```

```{r}
mean(multipleChoiceResponses$EmploymentStatus=="Employed full-time"|
       multipleChoiceResponses$EmploymentStatus=="Independent contractor, freelancer, or self-employed"|
     multipleChoiceResponses$EmploymentStatus=="Employed part-time"
     , na.rm=T)


mean(multipleChoiceResponses$EmploymentStatus=="Employed full-time"|multipleChoiceResponses$EmploymentStatus=="Employed part-time"
     , na.rm=T)

mean(multipleChoiceResponses$EmploymentStatus=="Independent contractor, freelancer, or self-employed"
     , na.rm=T)


mean(multipleChoiceResponses$CareerSwitcher=="Yes", na.rm=T)
median(multipleChoiceResponses$CareerSwitcher=="Yes", na.rm=T)

#Aggregate the demographics for countries
t.cut<-multipleChoiceResponses[!is.na(Country),] %>%
  .[,.(NCount=.N, 
        AgeMedian = as.numeric(median(Age, na.rm=T)),
        CareerSwitcherP=as.numeric(mean(CareerSwitcher=="Yes", na.rm=T)),
       WorkingP=mean(EmploymentStatus=="Employed full-time"|
                       EmploymentStatus=="Independent contractor, freelancer, or self-employed"|EmploymentStatus=="Employed part-time", na.rm=T),
       LookingForJobP=mean(EmploymentStatus=="Not employed, but looking for work", na.rm=T),
       StudentP=mean(StudentStatus=="Yes", na.rm=T),
       WorkingExpMedian= Median()
   ), 
   by=c("Country")]



```



```{r}

m <- leaflet() %>% setView(lng = 0, lat = 0, zoom = 1)%>%addTiles()


leaflet() %>% addTiles()%>%addProviderTiles(providers$CartoDB.Positron)
```

```{r}

highchart() %>% 
  hc_add_series_map(worldgeojson, GNI2010,
                    value = "GNI", joinBy = "iso3")
```

#Trashes now

```{r}
mpgg <- mpg %>% 
  filter(class %in% c("suv", "compact", "midsize")) %>% 
  group_by(class, manufacturer) %>% 
  summarize(count = n())

categories_grouped <- mpgg %>% 
  group_by(name = class) %>% 
  do(categories = .$manufacturer) %>% 
  list_parse()

highchart() %>% 
  hc_xAxis(categories = categories_grouped) %>% 
  hc_add_series(data = mpgg, type = "bar", hcaes(y = count, color = manufacturer),
                showInLegend = FALSE)


multipleChoiceResponses$LearningPlatformSelect< - as.character(multipleChoiceResponses$LearningPlatformSelect)
  
t.splits <- max(lengths(strsplit(multipleChoiceResponses$LearningPlatformSelect, ",")))

t.test <- multipleChoiceResponses[,.(LearningPlatformSelect)] %>%
  .[, paste0("m.platformSelect", 1:splits):=tstrsplit(LearningPlatformSelect, '\\([^)]+,(*SKIP)(*FAIL)|,\\s*', perl = TRUE)] %>%
  .[, colnames(.) %like% "m.platformSelect",with=FALSE] %>%
  melt(.,  measure.vars = patterns("^m.platformSelect"))
  

hchart(test$value, type="bar")

multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^JobSkillImpo.*", with=FALSE]

multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^LearningCat.*", with=FALSE]

```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^WorkToolsF*", with=FALSE]
```


```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^WorkMethod*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^Time*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^Time*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^WorkData*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^WorkChallenge*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^JobFactor*", with=FALSE]
```

